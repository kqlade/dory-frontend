

==========================================
FILE: src/background/api.ts
==========================================

/**
 * @file api.ts
 * Exposes a background API (via Comlink) that content scripts can call.
 */

// Import service instances
import { authService } from '../services/authService';
import { contentService } from '../services/contentService';
import { clusteringService } from '../services/clusteringService';
import { searchService } from '../services/searchService';
import { eventService } from '../services/eventService';
import preferencesService from '../services/preferencesService';
import navigationService from '../services/navigationService';
import uiCommandService from '../services/uiCommandService';
import { isDatabaseInitialized } from '../db/DatabaseCore';

// Import types
import type { SearchOptions } from '../services/searchService'; 
import type { UserPreferences } from '../db/repositories/PreferencesRepository'; 
import type { ContentData, ClusterSuggestion, AuthState, SearchResult, BrowsingSession, ExtractedContent, VisitRecord } from '../types';
import * as Comlink from 'comlink'; 

// --- Define API types for Comlink exposure ---
// These interfaces define what methods are available AND what they return
// AFTER being potentially wrapped by Comlink (async operations return Promises)

// System Service API for initialization and status checks
export interface SystemServiceAPI {
  isReady(): Promise<boolean>;
}

// Auth Service API
export interface AuthServiceAPI {
  login(): Promise<void>; 
  logout(): Promise<void>;
  getAuthState(): Promise<AuthState>; 
}

// Clustering Service API
export interface ClusteringServiceAPI {
  getClusterSuggestions(options?: { forceRefresh?: boolean; count?: number }): Promise<{ current: ClusterSuggestion[]; previous: ClusterSuggestion[] }>; 
  triggerClustering(): Promise<void>; 
}

// Search Service API
export interface SearchServiceAPI {
  searchLocal(query: string): Promise<SearchResult[]>;
  searchSemantic(query: string, options?: SearchOptions): Promise<SearchResult[]>;
  searchHybrid(query: string, options?: SearchOptions): Promise<{ localResults: SearchResult[]; semanticResults: SearchResult[] }>; 
}

// Event Service API
export interface EventServiceAPI {
  trackSearchClick(searchSessionId: string, pageId: string, position: number, url: string, query: string): Promise<void>; 
  trackSearchPerformed(query: string, resultCount: number, searchType: 'local' | 'semantic' | 'hybrid'): Promise<{ searchSessionId: string }>; 
  trackNavigationEvent(fromUrl: string, toUrl: string, properties?: any): Promise<void>;
}

// Preferences Service API
export interface PreferencesServiceAPI {
  getPreferences(): Promise<UserPreferences>;
  getTheme(): Promise<UserPreferences['theme']>;
  toggleTheme(): Promise<UserPreferences['theme']>; 
  setTheme(theme: UserPreferences['theme']): Promise<UserPreferences['theme']>; 
}

// Content Service & Extractor API
export interface ContentExtractorAPI {
  extractContent(options?: { retryCount?: number }): Promise<ExtractedContent>;
  isPageReady(): Promise<boolean>;
}

// Content Service API
export interface ContentServiceAPI {
  extractContent(tabId: number): Promise<ExtractedContent | null>;
  extractAndSendContent(tabId: number, contextData: { pageId: string; visitId: string; sessionId: string | null; }): Promise<boolean>;
  sendContent(content: ContentData): Promise<boolean>;
  registerContentExtractor(tabId: number, port: MessagePort): Promise<boolean>;
  unregisterContentExtractor(tabId: number): Promise<boolean>;
}

// Activity Service API
export interface ActivityServiceAPI {
  reportActivity(data: { isActive: boolean; pageUrl: string; duration: number }): Promise<boolean>; 
}

// Navigation Service API
export interface NavigationServiceAPI {
  createOrGetPage(url: string, title: string, timestamp: number): Promise<string>;
  startVisit(pageId: string, sessionId: string, fromPageId?: string, isBackNav?: boolean): Promise<string>;
  endVisit(visitId: string, timestamp: number): Promise<void>; 
  getVisit(visitId: string): Promise<VisitRecord | null>;
  createOrUpdateEdge(fromPageId: string, toPageId: string, sessionId: string, timestamp: number, isBackNav: boolean): Promise<void>;
  ensureActiveSession(): Promise<string>;
  getCurrentSessionId(): Promise<string | null>;
  updateSessionActivityTime(duration: number): Promise<boolean>;
  startSession(): Promise<string>; 
  getCurrentSession(): Promise<BrowsingSession | null>; 
  endCurrentSession(): Promise<void>; 
}

// UI Command Service API
export interface UICommandServiceAPI {
  registerCommandHandler(tabId: number, port: MessagePort): Promise<boolean>; 
  unregisterCommandHandler(tabId: number): Promise<boolean>; 
  showSearchOverlay(tabId: number, action: 'show' | 'hide' | 'toggle'): Promise<boolean>; 
}

// --- Main Background API exposed via Comlink ---

// Tracks content extractor connections by tab ID
const contentExtractors: Record<number, Comlink.Remote<ContentExtractorAPI> | null> = {};

// This is the actual object passed to Comlink.expose
// We maintain the same structure as the original implementation
// but with proper typing for Comlink's Promise wrapping
export const backgroundApi = {
  // System status and initialization checking
  system: {
    /**
     * Check if the database is ready for use
     * @returns True if database is properly initialized
     */
    isReady: () => isDatabaseInitialized(),
  },
  auth: {
    login: () => authService.login(),
    logout: () => authService.logout(),
    getAuthState: () => authService.getAuthState(),
  },

  clusters: {
    getClusterSuggestions: (options?: { forceRefresh?: boolean; count?: number }) => 
      clusteringService.getClusterSuggestions(options),
    triggerClustering: () => clusteringService.triggerClustering(),
  },
  
  search: {
    /**
     * Perform a local search using browser history and local database
     */
    searchLocal: (query: string) => 
      searchService.searchLocal(query),
      
    /**
     * Perform a semantic search via the backend API
     */
    searchSemantic: (query: string, options?: SearchOptions) => 
      searchService.searchSemantic(query, options),
      
    /**
     * Perform both local and semantic search in parallel
     */
    searchHybrid: (query: string, options?: SearchOptions) => 
      searchService.searchHybrid(query, options),
  },
  
  events: {
    /**
     * Track a search result click event
     */
    trackSearchClick: (searchSessionId: string, pageId: string, position: number, url: string, query: string) => 
      eventService.trackSearchClick(searchSessionId, pageId, position, url, query),
      
    /**
     * Track that a user performed a search
     */
    trackSearchPerformed: (query: string, resultCount: number, searchType: 'local' | 'semantic' | 'hybrid' = 'local') => 
      eventService.trackSearchPerformed(query, resultCount, searchType),
      
    /**
     * Track a generic navigation event
     */
    trackNavigationEvent: (fromUrl: string, toUrl: string, properties?: any) => 
      eventService.trackSearchPerformed(`Navigation: ${fromUrl} → ${toUrl}`, 0, "local"),
  },
  
  preferences: {
    /**
     * Get all user preferences
     */
    getPreferences: () => preferencesService.getPreferences(),
    
    /**
     * Get the current theme preference
     */
    getTheme: () => preferencesService.getTheme(),
    
    /**
     * Toggle between light and dark mode
     */
    toggleTheme: () => preferencesService.toggleTheme(),
    
    /**
     * Set the theme preference
     */
    setTheme: (theme: 'light' | 'dark' | 'system') => preferencesService.setTheme(theme),
  },

  content: {
    /**
     * Extracts content from a specified tab. Returns null on failure.
     */
    async extractContent(tabId: number): Promise<ExtractedContent | null> {
      try {
        const extractor = contentExtractors[tabId];
        if (!extractor) return null;
        if (!(await extractor.isPageReady())) return null;
        return await extractor.extractContent();
      } catch (err) {
        console.error(`[BackgroundAPI] extractContent failed (tab ${tabId}):`, err);
        return null;
      }
    },

    /**
     * Extracts content from a tab and sends it directly to the backend.
     * @param tabId The tab ID to extract content from
     * @param contextData Additional context data like pageId, visitId, sessionId
     * @returns True if extraction and sending was successful
     */
    // Fixed to avoid using 'this' inside method
    extractAndSendContent: async (tabId: number, contextData: { 
      pageId: string; 
      visitId: string; 
      sessionId: string | null;
    }): Promise<boolean> => {
      try {
        console.log(`[BackgroundAPI] Extracting and sending content for tab ${tabId}`);
        
        // First extract the content - explicitly reference the function
        // instead of using 'this'
        const content = await backgroundApi.content.extractContent(tabId);
        if (!content) {
          console.warn(`[BackgroundAPI] Failed to extract content from tab ${tabId}`);
          return false;
        }
        
        // Combine extracted content with context data
        const contentData: ContentData = {
          ...contextData,
          url: content.url,
          title: content.title,
          markdown: content.markdown,
          metadata: content.metadata
        };
        
        // Send the content to the backend
        return await contentService.sendContent(contentData);
      } catch (err) {
        console.error(`[BackgroundAPI] extractAndSendContent failed (tab ${tabId}):`, err);
        return false;
      }
    },

    /**
     * Sends already extracted content to the backend
     * @param content The content data to send
     * @returns True if sending was successful
     */
    async sendContent(content: ContentData): Promise<boolean> {
      try {
        return await contentService.sendContent(content);
      } catch (err) {
        console.error('[BackgroundAPI] sendContent failed:', err);
        return false;
      }
    },

    registerContentExtractor: (tabId: number, port: MessagePort): Promise<boolean> => {
      contentExtractors[tabId] = Comlink.wrap<ContentExtractorAPI>(port);
      return Promise.resolve(true);
    },

    unregisterContentExtractor: (tabId: number): Promise<boolean> => {
      delete contentExtractors[tabId];
      return Promise.resolve(true);
    },
  },

  activity: {
    /**
     * Reports activity from content scripts.
     * Insert your own handling logic here.
     */
    reportActivity: (data: { isActive: boolean; pageUrl: string; duration: number }): Promise<boolean> => {
      console.log('[BackgroundAPI] Activity reported:', data);
      return Promise.resolve(true);
    },
  },

  navigation: {
    /**
     * Create or get a page record by URL
     */
    createOrGetPage: (url: string, title: string, timestamp: number) => 
      navigationService.createOrGetPage(url, title, timestamp),
    
    /**
     * Start a visit to a page
     */
    startVisit: (pageId: string, sessionId: string, fromPageId?: string, isBackNav?: boolean) => 
      navigationService.startVisit(pageId, sessionId, fromPageId, isBackNav),
    
    /**
     * End a visit to a page
     */
    endVisit: (visitId: string, timestamp: number) => 
      navigationService.endVisit(visitId, timestamp),
    
    /**
     * Get a visit by ID
     */
    getVisit: (visitId: string) => 
      navigationService.getVisit(visitId),
    
    /**
     * Create or update a navigation edge between pages
     */
    createOrUpdateEdge: (fromPageId: string, toPageId: string, sessionId: string, timestamp: number, isBackNav: boolean) => 
      navigationService.createOrUpdateEdge(fromPageId, toPageId, sessionId, timestamp, isBackNav),
    
    /**
     * Ensure an active session exists, creating one if needed
     */
    ensureActiveSession: () => 
      navigationService.ensureActiveSession(),
    
    /**
     * Get the current session ID
     */
    getCurrentSessionId: () => 
      navigationService.getCurrentSessionId(),
      
    /**
     * Update the session activity time
     */
    updateSessionActivityTime: (duration: number) => 
      navigationService.updateSessionActivityTime(duration),
      
    /**
     * Start a new session
     */
    startSession: () => 
      navigationService.ensureActiveSession(), // Use ensureActiveSession instead of startNewSession

    /**
     * Get the current session
     */
    /**
     * Get the current session
     */
    getCurrentSession: async () => {
      // Need to await the Promise returned by getCurrentSessionId
      const sessionId = await navigationService.getCurrentSessionId();
      if (!sessionId) return null;
      
      // Now use the string sessionId to get the visit record
      return navigationService.getVisit(sessionId);
    },

    /**
     * End the current session
     */
    endCurrentSession: () => 
      navigationService.endCurrentSession(), // Use endCurrentSession directly
  },

  commands: {
    /**
     * Register a content script's command handler
     * @param tabId The tab ID to register
     * @param port The MessagePort to use for communication
     * @returns Success status
     */
    registerCommandHandler: (tabId: number, port: MessagePort) => 
      uiCommandService.registerCommandHandler(tabId, port),
    
    /**
     * Unregister a command handler
     * @param tabId The tab ID to unregister
     * @returns Success status
     */
    unregisterCommandHandler: (tabId: number) => 
      uiCommandService.unregisterCommandHandler(tabId),
    
    /**
     * Shows or toggles the search overlay in a specific tab
     * @param tabId Target tab ID for showing overlay
     * @param action 'show', 'hide', or 'toggle'
     * @returns Promise resolving to success status
     */
    showSearchOverlay: (tabId: number, action: 'show' | 'hide' | 'toggle' = 'toggle') => 
      uiCommandService.showSearchOverlay(tabId, action),
  },
};

// --- Define the final BackgroundAPI type for frontend use ---

// This is the type the frontend (hooks) will use via getBackgroundAPI<BackgroundAPI>()
// It reflects the structure of backgroundApi above.
// The getBackgroundAPI() function returns a Promise, but the properties themselves 
// are direct objects with methods that return Promises
export type BackgroundAPI = {
  system: SystemServiceAPI;
  auth: AuthServiceAPI;
  clusters: ClusteringServiceAPI;
  search: SearchServiceAPI;
  events: EventServiceAPI;
  preferences: PreferencesServiceAPI;
  content: ContentServiceAPI;
  activity: ActivityServiceAPI;
  navigation: NavigationServiceAPI;
  commands: UICommandServiceAPI;
};

==========================================
FILE: src/background/queryClient.ts
==========================================

import { QueryClient } from '@tanstack/react-query';

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false,
      retry: false,
      staleTime: 1000 * 60 * 5, // 5 minutes
    },
  },
}); 

==========================================
FILE: src/background/serviceWorker.ts
==========================================

/**
 * @file serviceWorker.ts
 * 
 * Background script for the Dory extension.
 * Sets up the background API, coordinates navigation, and manages extension lifecycle.
 */

import { authService } from '../services/authService';
import { backgroundApi } from './api';
import { exposeBackgroundAPI } from '../utils/comlinkSetup';
import { isWebPage, shouldRecordHistoryEntry } from '../utils/urlUtils';

// -------------------- Constants & State --------------------
const SESSION_IDLE_THRESHOLD = 15 * 60 * 1000; // 15 min

let isSessionActive = false;
let idleCheckInterval: ReturnType<typeof setInterval> | null = null;

/**
 * Track data about each open tab with separate maps for different properties
 */
const tabToCurrentUrl: Record<number, string | undefined> = {};
const tabToPageId: Record<number, string> = {}; // Tracks PageID of the *last valid* visit
const tabToVisitId: Record<number, string> = {}; // Tracks VisitID of the *current valid* visit
const extractionRequestedForVisitId: Record<number, string> = {}; // Tracks the last visitId extraction was requested for

// -------------------- Initialization --------------------

// This function immediately initializes everything in the correct sequence
async function initializeExtension() {
  try {
    console.log('[Background] Starting extension initialization...');
    
    // 1. Initialize auth first - this is fast and synchronous
    await authService.init();
    const authState = await authService.getAuthState();
    const isAuthenticated = authState.isAuthenticated;
    
    console.log(`[Background] Auth initialized. Authenticated: ${isAuthenticated}`);
    updateIcon(isAuthenticated);
    
    // If not authenticated, just exit - we'll initialize on login
    if (!isAuthenticated) {
      console.log('[Background] Not authenticated. Waiting for login.');
      return;
    }
    
    // 2. Initialize database with user ID - happens immediately
    const { DatabaseManager } = await import('../db/DatabaseCore');
    if (authState.user?.id) {
      DatabaseManager.setCurrentUser(authState.user.id);
      console.log(`[Background] Database initialized with user: ${authState.user.id}`);
    }
    
    // 3. Initialize session immediately after database
    await backgroundApi.navigation.ensureActiveSession();
    console.log('[Background] Session initialized');
    
    // 4. Now that core initialization is done, set up background tasks
    isSessionActive = true;
    idleCheckInterval = setInterval(checkSessionInactivity, 60000);
    setupScheduledTasks();
    injectGlobalSearchIntoExistingTabs();
    
    console.log('[Background] Initialization complete - all systems ready!');
  } catch (error) {
    console.error('[Background] Initialization error:', error);
  }
}

// Start initialization immediately
initializeExtension();

// Expose the API to content scripts
exposeBackgroundAPI(backgroundApi);

// Initialize the extension
console.log('[Background] Service worker initializing...');

// -------------------- Icon Helpers --------------------
function updateIcon(isAuthenticated: boolean) {
  const iconPath = isAuthenticated
    ? {
        16: '/icons/dory_logo_16x16.png',
        48: '/icons/dory_logo_48x48.png',
        128: '/icons/dory_logo_128x128.png'
      }
    : {
        16: '/icons/dory_logo_gray_16x16.png',
        48: '/icons/dory_logo_gray_48x48.png',
        128: '/icons/dory_logo_gray_128x128.png'
      };
  chrome.action.setIcon({ path: iconPath });
}

// -------------------- Service Initialization --------------------
async function initializeServices() {
  try {
    console.log('[Background] Starting service initialization...');
    
    // 1. First check authentication status - GATE EVERYTHING on this
    const authState = await backgroundApi.auth.getAuthState();
    if (!authState.isAuthenticated || !authState.user?.id) {
      // Not authenticated - just set up icon and exit
      console.log('[Background] User not authenticated. Services will initialize after login.');
      updateIcon(false);
      return; // Exit initialization until user logs in
    }
    
    console.log(`[Background] User authenticated: ${authState.user.id}`);
    updateIcon(true);
    
    // 2. Initialize database with the user ID
    console.log('[Background] Initializing database...');
    const { initializeDatabase, isDatabaseInitialized } = await import('../db/DatabaseCore');
    
    // Database initialization sets the user ID
    await initializeDatabase();
    
    // Verify database was initialized properly
    if (!isDatabaseInitialized()) {
      throw new Error('Database failed to initialize');
    }
    console.log('[Background] Database initialized successfully');
    
    // 3. Initialize session - depends on database
    console.log('[Background] Initializing session...');
    const sessionSuccess = await backgroundApi.navigation.ensureActiveSession();
    if (!sessionSuccess) {
      throw new Error('Failed to initialize session');
    }
    console.log('[Background] Session initialized successfully');
    
    // 4. Now that critical services are ready, initialize the rest
    console.log('[Background] Initializing remaining services...');
    
    // Set up idle check interval
    idleCheckInterval = setInterval(checkSessionInactivity, 60000);
    
    // Initialize scheduled tasks
    setupScheduledTasks();
    
    // Inject global search into existing tabs
    injectGlobalSearchIntoExistingTabs();
    
    // Mark system as fully initialized
    isSessionActive = true;
    console.log('[Background] All services initialized successfully');
  } catch (error) {
    // Clear any in-progress state
    if (idleCheckInterval) {
      clearInterval(idleCheckInterval);
      idleCheckInterval = null;
    }
    
    isSessionActive = false;
    console.error('[Background] Service initialization failed:', error);
    updateIcon(false);
  }
}

// -------------------- Command Handling --------------------

// Handle keyboard shortcut commands
chrome.commands.onCommand.addListener(async (command) => {
  console.log(`[Background] Command received: ${command}`);
  
  if (command === 'activate-global-search') {
    
    const tabs = await chrome.tabs.query({ active: true, currentWindow: true });
    if (!tabs || !tabs[0] || !tabs[0].id) {
      console.error('[Background] No active tab found');
      return;
    }
    
    const tabId = tabs[0].id;
    const url = tabs[0].url;
    
    // Skip injection for non-web pages
    if (!url || !isWebPage(url)) {
      console.log(`[Background] Skipping global search on non-web page: ${url}`);
      return;
    }
    
    // Show search overlay using the commands API via Comlink
    try {
      const success = await backgroundApi.commands.showSearchOverlay(tabId, 'toggle');
      if (success) {
        console.log(`[Background] Search overlay toggled for tab ${tabId}`);
      } else {
        console.warn(`[Background] Failed to toggle search overlay for tab ${tabId}`);
      }
    } catch (error) {
      console.error(`[Background] Error toggling search overlay:`, error);
    }
  } 
  else if (command === 'toggle-side-panel') {
    const tabs = await chrome.tabs.query({ active: true, currentWindow: true });
    if (!tabs || !tabs[0] || !tabs[0].id) {
      console.error('[Background] No active tab found for side panel');
      return;
    }
    
    try {
      await chrome.sidePanel.open({ tabId: tabs[0].id });
      console.log('[Background] Side panel opened via keyboard shortcut');
    } catch (err) {
      console.error('[Background] Error opening side panel:', err);
    }
  }
  else if (command === 'toggle-cluster-view') {
    // Find the active New Tab page (if any)
    const tabs = await chrome.tabs.query({ active: true, currentWindow: true });
    if (tabs && tabs[0] && tabs[0].id && tabs[0].url?.startsWith('chrome://newtab')) {
      try {
        await chrome.tabs.sendMessage(tabs[0].id, { type: 'TOGGLE_CLUSTER_VIEW' });
        console.log('[Background] Sent TOGGLE_CLUSTER_VIEW message to New Tab');
      } catch (err) {
        console.error('[Background] Failed to send TOGGLE_CLUSTER_VIEW message:', err);
      }
    } else {
      console.log('[Background] toggle-cluster-view command ignored: Not on New Tab page.');
    }
  }
});

// -------------------- Navigation & History Tracking --------------------

/**
 * Helper to get the title for a given tab
 */
async function getTabTitle(tabId: number): Promise<string | null> {
  try {
    const tab = await chrome.tabs.get(tabId);
    return tab.title || null;
  } catch (err) {
    console.warn(`[Background] Failed to get title for tab ${tabId}:`, err);
    return null;
  }
}

/**
 * End a visit and update state tracking
 */
async function endCurrentVisit(tabId: number, visitId?: string): Promise<void> {
  const visitIdToEnd = visitId || tabToVisitId[tabId];
  if (!visitIdToEnd) {
    return;
  }
  
  console.log(`[Background] Ending visit => tab: ${tabId}, visitId: ${visitIdToEnd}`);
  
  try {
    const now = Date.now();
    // Use navigation service through backgroundApi - it already handles tracking internally
    await backgroundApi.navigation.endVisit(visitIdToEnd, now);
  } catch (error) {
    console.error('[Background] Error ending visit:', error);
  }
}

/**
 * Start a new visit and update tab state
 */
async function startNewVisit(
  tabId: number,
  pageId: string,
  fromPageId?: string,
  isBackNav?: boolean
): Promise<string> {
  try {
    // Get session ID through navigation service
    const sessionId = await backgroundApi.navigation.getCurrentSessionId();
    
    if (!sessionId) {
      console.error('[Background] Cannot start visit: no active session');
      throw new Error('No active session found for startNewVisit');
    }
    
    console.log(`[Background] Starting new visit: tab=${tabId}, page=${pageId}, from=${fromPageId}`);
    
    // Start visit through navigation service
    const visitId = await backgroundApi.navigation.startVisit(pageId, sessionId, fromPageId, isBackNav);
    
    // Update local state tracking
    tabToVisitId[tabId] = visitId;
    
    // Navigation service already tracks visit starts internally
    
    console.log(`[Background] New visit started: ${visitId}`);
    return visitId;
  } catch (error) {
    console.error(`[Background] Error starting visit to page ${pageId}:`, error);
    throw error;
  }
}

/**
 * Process a navigation event from any source (committed, history state, fragment)
 */
async function processNavigationEvent(details: {
  tabId: number;
  url: string;
  timeStamp: number;
  frameId?: number;
  transitionType?: string;
  transitionQualifiers?: string[];
}): Promise<void> {
  // Skip non-main frames
  if (details.frameId !== undefined && details.frameId !== 0) return;
  
  const { tabId, url, timeStamp } = details;
  
  // Basic validity checks
  if (tabId < 0 || !isWebPage(url)) {
    console.log(`[Background] Skipping navigation: invalid tab or non-web page (${url})`);
    return;
  }
  
  try {
    // Get context for the new page
    const title = (await getTabTitle(tabId)) || url;
    
    // Get previous state
    const previousVisitId = tabToVisitId[tabId];
    const pageIdFromPreviousVisit = tabToPageId[tabId];
    const previousUrl = tabToCurrentUrl[tabId];
    
    // Only process if URL has meaningfully changed
    if (!previousUrl || previousUrl !== url) {
      console.log(`[Background] Navigation in tab ${tabId}: ${previousUrl || 'None'} → ${url}`);
      
      // End previous visit if it existed
      if (previousVisitId) {
        await endCurrentVisit(tabId, previousVisitId);
      }
      
      // Clear current visit state
      delete tabToVisitId[tabId];
      delete tabToPageId[tabId];
      
      // Check if the new page should be recorded
      const isValid = shouldRecordHistoryEntry(url, title, 'processNavigationEvent');
      
      // Always update the current URL
      tabToCurrentUrl[tabId] = url;
      
      // Skip invalid pages
      if (!isValid) {
        console.log(`[Background] Filtered navigation: skipping recording for ${url}`);
        delete extractionRequestedForVisitId[tabId];
        return;
      }
      
      // For valid pages, check auth and session
      console.log(`[Background] Valid navigation: recording ${url}`);
      const authState = authService.getAuthState();
      
      if (!authState.isAuthenticated) {
        console.warn(`[Background] Skipping valid navigation: not authenticated`);
        return;
      }
      
      // Ensure session is active
      const sessionActive = await backgroundApi.navigation.ensureActiveSession();
      if (!sessionActive) {
        console.warn(`[Background] Skipping valid navigation: no active session`);
        return;
      }
      
      // Create/get page record
      const newPageId = await backgroundApi.navigation.createOrGetPage(url, title, timeStamp);
      
      // Create edge if applicable
      const isBackNav = details.transitionQualifiers?.includes('forward_back') || false;
      const sessionId = await backgroundApi.navigation.getCurrentSessionId();
      
      if (sessionId && pageIdFromPreviousVisit && pageIdFromPreviousVisit !== newPageId) {
        try {
          console.log(`[Background] Creating edge: ${pageIdFromPreviousVisit} → ${newPageId}`);
          await backgroundApi.navigation.createOrUpdateEdge(
            pageIdFromPreviousVisit,
            newPageId,
            sessionId,
            timeStamp,
            isBackNav
          );
        } catch (error) {
          console.error(`[Background] Failed to create edge:`, error);
        }
      }
      
      // Start new visit
      const newVisitId = await startNewVisit(tabId, newPageId, pageIdFromPreviousVisit, isBackNav);
      
      // Update state for new visit
      tabToPageId[tabId] = newPageId;
      tabToVisitId[tabId] = newVisitId;
      
      console.log(`[Background] State updated: pageId=${newPageId}, visitId=${newVisitId}`);
      
      // Trigger content extraction if needed
      if (extractionRequestedForVisitId[tabId] !== newVisitId) {
        console.log(`[Background] Requesting content extraction for visit ${newVisitId}`);
        try {
          // Request content extraction through API
          await backgroundApi.content.extractAndSendContent(tabId, {
            pageId: newPageId,
            visitId: newVisitId,
            sessionId: sessionId
          });
          extractionRequestedForVisitId[tabId] = newVisitId;
        } catch (error) {
          console.error(`[Background] Content extraction request failed:`, error);
        }
      }
    } else {
      console.log(`[Background] Skipping navigation: URL unchanged (${url})`);
    }
  } catch (error) {
    console.error(`[Background] Error processing navigation:`, error);
  }
}

// -------------------- Navigation Event Listeners --------------------

// Process all committed main-frame navigations
chrome.webNavigation.onCommitted.addListener(async (details) => {
  await processNavigationEvent(details);
});

// Process SPA navigations
chrome.webNavigation.onHistoryStateUpdated.addListener(async (details) => {
  await processNavigationEvent(details);
});

// Process hash fragment navigations
chrome.webNavigation.onReferenceFragmentUpdated.addListener(async (details) => {
  await processNavigationEvent(details);
});

// Handle new tabs created from existing tabs
chrome.webNavigation.onCreatedNavigationTarget.addListener(async (details) => {
  const { sourceTabId, tabId, timeStamp, url } = details;
  console.log(`[Background] Created navigation target: source=${sourceTabId}, target=${tabId}, url=${url}`);
  
  // Check if target URL should be recorded
  if (!shouldRecordHistoryEntry(url, null, 'onCreatedNavigationTarget')) {
    console.log(`[Background] Filtered navigation target: skipping ${url}`);
    return;
  }
  
  // Check auth
  const authState = authService.getAuthState();
  if (!authState.isAuthenticated) return;
  
  try {
    // Ensure active session
    const sessionActive = await backgroundApi.navigation.ensureActiveSession();
    if (!sessionActive) {
      console.warn(`[Background] Skipping navigation target: no active session`);
      return;
    }
    
    // Track relationship between source and target tabs
    const oldUrl = tabToCurrentUrl[sourceTabId];
    // Ensure sourceTitle is always a string, with a fallback to URL or a default value
    const sourceTitle = (await getTabTitle(sourceTabId)) || oldUrl || 'Unknown Page';
    
    if (oldUrl && shouldRecordHistoryEntry(oldUrl, sourceTitle, 'onCreatedNavigationTarget_SourceCheck')) {
      // Create/get page for source URL
      const fromPageId = await backgroundApi.navigation.createOrGetPage(oldUrl, sourceTitle, timeStamp);
      // Store pending navigation state
      tabToCurrentUrl[tabId] = `pending:${fromPageId}`;
      console.log(`[Background] Stored pending navigation from pageId: ${fromPageId}`);
    } else {
      console.log(`[Background] Source tab URL unknown or invalid (${oldUrl})`);
      tabToCurrentUrl[tabId] = url;
    }
  } catch (error) {
    console.error(`[Background] Error handling navigation target:`, error);
  }
});

// -------------------- Browser Event Handlers --------------------

// Handle extension icon clicks to open the side panel
chrome.action.onClicked.addListener(async (tab) => {
  if (!tab.id) {
    console.error('[Background] No tab ID => cannot interact with tab');
    return;
  }

  try {
    console.log('[Background] Opening side panel for authentication');
    await chrome.sidePanel.open({ tabId: tab.id });
  } catch (err) {
    console.error('[Background] Error opening side panel:', err);
  }
});

// -------------------- Tab Lifecycle Management --------------------

// Handle tab removal
chrome.tabs.onRemoved.addListener((tabId) => {
  console.log(`[Background] Tab ${tabId} removed`);
  
  // Unregister content extractor for closed tabs
  backgroundApi.content.unregisterContentExtractor(tabId);
  
  // Clean up navigation tracking state
  delete tabToCurrentUrl[tabId];
  delete tabToPageId[tabId];
  delete tabToVisitId[tabId];
  delete extractionRequestedForVisitId[tabId];
});

// Track tab creation
chrome.tabs.onCreated.addListener((tab) => {
  if (tab.id !== undefined && tab.url) {
    tabToCurrentUrl[tab.id] = tab.url;
  }
});

// -------------------- Global Search Integration --------------------

/**
 * Helper function to inject global search content script into a tab
 */
async function injectGlobalSearch(tabId: number): Promise<boolean> {
  try {
    console.log(`[Background] Injecting global search into tab ${tabId}`);
    
    await chrome.scripting.executeScript({
      target: { tabId },
      files: ['src/content/globalSearch.js']
    });
    
    return true;
  } catch (error) {
    console.error(`[Background] Failed to inject global search into tab ${tabId}:`, error);
    return false;
  }
}

/**
 * Function to inject global search into all existing tabs
 */
async function injectGlobalSearchIntoExistingTabs(): Promise<void> {
  try {
    const tabs = await chrome.tabs.query({});
    console.log(`[Background] Injecting global search into ${tabs.length} existing tabs`);
    
    let injectedCount = 0;
    for (const tab of tabs) {
      if (tab.id && tab.url && isWebPage(tab.url)) {
        try {
          const success = await injectGlobalSearch(tab.id);
          if (success) injectedCount++;
        } catch (err) {
          console.log(`[Background] Could not inject into tab ${tab.id} (${tab.url}):`, err);
        }
      }
    }
    console.log(`[Background] Successfully injected global search into ${injectedCount}/${tabs.length} tabs`);
  } catch (error) {
    console.error('[Background] Error injecting global search into existing tabs:', error);
  }
}

// -------------------- Session Management --------------------

/**
 * Check for session inactivity
 */
async function checkSessionInactivity() {
  if (!isSessionActive) return;
  
  try {
    // Use auth service to check if still authenticated
    const authState = authService.getAuthState();
    if (!authState.isAuthenticated) {
      console.log('[Background] No longer authenticated, ending session');
      cleanupServices();
      return;
    }
    
    // Update session activity tracking
    console.log('[Background] Checking session activity...');
  } catch (error) {
    console.error('[Background] Error checking session activity:', error);
  }
}

/**
 * Clean up services on session end or extension shutdown
 */
function cleanupServices() {
  console.log('[Background] Cleaning up services...');
  
  // Clear the idle interval
  if (idleCheckInterval) {
    clearInterval(idleCheckInterval);
    idleCheckInterval = null;
  }
  
  isSessionActive = false;
  console.log('[Background] Services cleaned up');
}

/**
 * Set up scheduled tasks like cold storage sync
 */
function setupScheduledTasks() {
  // Set up an alarm for cold storage sync
  chrome.alarms.create('doryColdStorageSync', {
    periodInMinutes: 5 // Every 5 minutes
  });
  
  // Listen for alarms
  chrome.alarms.onAlarm.addListener(handleAlarm);
  
  console.log('[Background] Scheduled tasks set up');
}

/**
 * Handle alarm triggers
 */
async function handleAlarm(alarm: chrome.alarms.Alarm) {
  console.log(`[Background] Alarm triggered: ${alarm.name}`);
  
  if (alarm.name === 'doryColdStorageSync') {
    const authState = authService.getAuthState();
    if (!authState.isAuthenticated) {
      console.log('[Background] Skipping task: Not authenticated');
      return;
    }
    
    console.log('[Background] Initiating cold storage sync task');
    // Would delegate to a service via background API in the full implementation
  }
}

// -------------------- Extension Lifecycle --------------------

// Handle install/update
chrome.runtime.onInstalled.addListener((details) => {
  console.log(`[Background] Extension ${details.reason}:`, details);
  
  // Inject global search on install/update
  injectGlobalSearchIntoExistingTabs();
});

// Handle suspension (service worker termination)
chrome.runtime.onSuspend.addListener(() => {
  console.log('[Background] Service worker suspending...');
  cleanupServices();
});

console.log('[Background] Service worker initialized.');



==========================================
FILE: src/components/ClusterContainer.css
==========================================

.cluster-container {
  width: 100%;
  margin-top: 15px; /* Reduced space between search bar and clusters (halved from 20px) */
}

/* Grid layout for the three squares */
.cluster-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr); /* Three equal columns */
  gap: 20px; /* Gap between squares */
  width: 100%; /* Match width of parent container */
  margin: 0; /* No margin so it aligns with the edges of the container */
}

/* Standalone popup with no overlay */
.expanded-cluster-view {
  position: fixed;
  top: calc(52vh + 15px); /* Match the top position of actual task cards (clusters-wrapper + margin-top) */
  left: 50%;
  transform: translateX(-50%); /* Only center horizontally */
  background-color: var(--bg-color, #ffffff); /* Match new tab page background */
  border-radius: 12px;
  /* Match search bar width exactly */
  width: 600px;
  max-width: 90%;
  box-sizing: border-box;
  padding: 0;
  max-height: 80vh;
  overflow-y: auto;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
  z-index: 1000;
  animation: slideIn 0.3s ease-out;
  border: 1px solid var(--border-color, rgba(0, 0, 0, 0.3));
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateX(-50%) translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateX(-50%);
  }
}

/* Adjust padding to match search bar */
.expanded-cluster-header, 
.expanded-cluster-content {
  padding: 16px 20px;
}

.expanded-cluster-header {
  padding: 16px 20px 2px; /* Reduced bottom padding from 16px to 4px */
  text-align: center;
  position: relative; /* Keep for consistent positioning */
}

.expanded-cluster-header h2 {
  margin: 0;
  font-size: 1.4rem;
  color: var(--text-color, #000000);
  font-family: 'Cabinet Grotesk', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  font-weight: 500;
  letter-spacing: 0.05em;
  text-align: center;
}

.page-list {
  display: none; /* Hide old styling */
}

/* Results/pages list - matching search results exactly */
.results-list {
  list-style: none;
  margin: 0; /* Removed top margin completely (was 8px) */
  padding: 0;
  max-height: 50vh;
  overflow-y: auto;
  border-top: 1px solid var(--border-color);
  transition: max-height 0.3s ease, opacity 0.3s ease;
  opacity: 1;
}

.result-item {
  padding: 10px 12px;
  cursor: pointer;
  transition: background-color 0.2s;
  border-radius: 8px;
  margin: 4px 0;
}

.result-item:hover {
  background-color: var(--item-hover-bg);
}

.result-item.selected {
  background-color: var(--item-hover-bg);
  border-left: 3px solid var(--border-focus-color);
  padding-left: 9px; /* 12px - 3px border */
}

/* Title, URL, explanation */
.result-title {
  font-size: 16px;
  font-weight: 500;
  color: var(--text-primary);
  margin-bottom: 4px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.result-url {
  font-size: 12px;
  color: var(--text-secondary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.result-explanation {
  font-size: 12px;
  color: var(--text-secondary);
  margin-top: 4px;
  line-height: 1.4;
  opacity: 0.9;
  font-style: italic;
}

.explanation-label {
  font-weight: 600;
  font-style: normal;
}

/* Status message for empty state */
.status-message {
  text-align: center;
  padding: 10px 12px;
  color: var(--text-secondary);
  min-height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: opacity 0.2s ease;
  border-radius: 8px;
  margin: 4px 0;
}

/* Close button styles removed as per request */

/* Responsive adjustments */
@media (max-width: 768px) {
  .cluster-grid {
    gap: 15px;
  }
  
  .expanded-cluster-view {
    width: 90%;
    /* Keep aligned with clusters at this breakpoint */
    top: calc(50vh + 15px);
  }
  
  .expanded-cluster-header h2 {
    font-size: 1.2rem;
    letter-spacing: 0.075em;
  }
}

@media (max-width: 480px) {
  .cluster-grid {
    grid-template-columns: repeat(3, 1fr); /* Keep three squares in a row */
    gap: 10px;
  }
  
  .expanded-cluster-view {
    width: 95%;
    /* Keep aligned with clusters at this breakpoint */
    top: calc(38vh + 15px);
  }
  
  .expanded-cluster-header h2 {
    font-size: 1.1rem;
    letter-spacing: 0.05em;
  }
}

@media (min-width: 1024px) {
  .expanded-cluster-header h2 {
    font-size: 1.6rem;
  }
}

/* Dark mode adjustments */
@media (prefers-color-scheme: dark) {
  .expanded-cluster-view {
    background-color: var(--bg-color, #000000);
    border-color: var(--border-color, rgba(255, 255, 255, 0.3));
  }
  
  .expanded-cluster-header h2 {
    color: var(--text-color, #ffffff);
  }
  
  .results-list {
    border-top-color: var(--border-color, rgba(255, 255, 255, 0.3));
  }
  
  .result-item:hover,
  .result-item.selected {
    background-color: var(--item-hover-bg, rgba(255, 255, 255, 0.05));
  }
  
  .result-title {
    color: var(--text-color, #ffffff);
  }
  
  .result-url,
  .result-explanation,
  .status-message {
    color: var(--text-secondary, rgba(255, 255, 255, 0.6));
  }
} 

==========================================
FILE: src/components/ClusterContainer.tsx
==========================================

import React, { useState, useEffect, useRef, WheelEvent } from 'react';
import ReactDOM from 'react-dom';
import ClusterSquare from './ClusterSquare';
import { ClusterSuggestion, ClusterPage } from '../types';
import useBackgroundClustering from '../hooks/useBackgroundClustering';
import './ClusterContainer.css';

interface ClusterContainerProps {
  clusters?: ClusterSuggestion[];
  clusterCount?: number;
}

/**
 * Displays a grid of cluster squares. Clicking a cluster shows an expanded view with pages.
 */
const ClusterContainer: React.FC<ClusterContainerProps> = ({
  clusters = [],
  clusterCount = 3,
}) => {
  const [expandedCluster, setExpandedCluster] = useState<ClusterSuggestion | null>(null);
  const [startIndex, setStartIndex] = useState(0);
  const [selectedPageIndex, setSelectedPageIndex] = useState(-1);
  const [isRefreshing, setIsRefreshing] = useState(false);

  const expandedViewRef = useRef<HTMLDivElement>(null);

  const { clusters: hookClusters, loading: loadingClusters, getClusters } =
    useBackgroundClustering();

  // Decide which cluster data to use (explicit prop vs. hook)
  const effectiveClusters = clusters.length ? clusters : hookClusters;

  // Fetch clusters on mount (or when clusterCount changes)
  useEffect(() => {
    if (clusterCount) getClusters({ count: clusterCount });
  }, [clusterCount, getClusters]);

  // Manually refresh clusters
  const refreshClusters = async () => {
    setIsRefreshing(true);
    await getClusters({ forceRefresh: true, count: clusterCount });
    setTimeout(() => setIsRefreshing(false), 3000);
  };

  // Opens expanded view for a cluster
  const handleClusterClick = (cluster?: ClusterSuggestion) => {
    if (cluster) {
      setExpandedCluster(cluster);
      setSelectedPageIndex(-1);
      setStartIndex(0);
    }
  };

  // Closes the expanded view
  const handleCloseExpanded = () => setExpandedCluster(null);

  // Opens pages in a new tab
  const handlePageClick = (page: ClusterPage) => {
    chrome.tabs.create({ url: page.url });
    // Optionally close expanded view, depending on UX preference
  };

  // Close the expanded view if user clicks outside it
  useEffect(() => {
    if (!expandedCluster) return;
    const handleClickOutside = (e: MouseEvent) => {
      if (
        expandedViewRef.current &&
        !expandedViewRef.current.contains(e.target as Node)
      ) {
        handleCloseExpanded();
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, [expandedCluster]);

  // Scroll the expanded cluster pages (3 at a time)
  const handleScroll = (e: WheelEvent<HTMLUListElement>) => {
    if (!expandedCluster) return;
    const pages = expandedCluster.top_pages || [];
    const maxIndex = Math.max(0, pages.length - 3);

    if (e.deltaY > 0 && startIndex < maxIndex) {
      e.preventDefault();
      setStartIndex(prev => Math.min(prev + 1, maxIndex));
    } else if (e.deltaY < 0 && startIndex > 0) {
      e.preventDefault();
      setStartIndex(prev => Math.max(prev - 1, 0));
    }
  };

  // Keyboard navigation for the expanded cluster
  useEffect(() => {
    if (!expandedCluster) return;
    const pages = expandedCluster.top_pages || [];
    const maxIndex = Math.max(0, pages.length - 3);

    const handleKeyDown = (e: KeyboardEvent) => {
      if (!expandedViewRef.current) return;
      switch (e.key) {
        case 'ArrowDown': {
          e.preventDefault();
          if (pages.length) {
            const newIndex =
              selectedPageIndex < pages.length - 1 ? selectedPageIndex + 1 : 0;
            setSelectedPageIndex(newIndex);
            if (newIndex >= startIndex + 3) {
              setStartIndex(Math.min(newIndex - 2, maxIndex));
            } else if (newIndex < startIndex) {
              setStartIndex(newIndex);
            }
          }
          break;
        }
        case 'ArrowUp': {
          e.preventDefault();
          if (pages.length) {
            const newIndex =
              selectedPageIndex > 0 ? selectedPageIndex - 1 : pages.length - 1;
            setSelectedPageIndex(newIndex);
            if (newIndex < startIndex) setStartIndex(newIndex);
            else if (newIndex >= startIndex + 3) setStartIndex(newIndex - 2);
          }
          break;
        }
        case 'Enter':
          if (selectedPageIndex >= 0 && selectedPageIndex < pages.length) {
            handlePageClick(pages[selectedPageIndex]);
          }
          break;
        case 'Escape':
          handleCloseExpanded();
          break;
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [expandedCluster, selectedPageIndex, startIndex]);

  // Render expanded cluster view via portal
  const renderExpandedView = () => {
    if (!expandedCluster) return null;
    const pages = expandedCluster.top_pages || [];
    const visible = pages.slice(startIndex, startIndex + 3);

    const content = (
      <div className="expanded-cluster-view" ref={expandedViewRef}>
        <div className="expanded-cluster-header">
          <h2>{expandedCluster.label}</h2>
        </div>
        <div className="expanded-cluster-content">
          {pages.length ? (
            <ul className="results-list" onWheel={handleScroll}>
              {visible.map((p, idx) => {
                const actualIndex = startIndex + idx;
                return (
                  <li
                    key={p.page_id}
                    className={`result-item ${
                      actualIndex === selectedPageIndex ? 'selected' : ''
                    }`}
                    onClick={() => handlePageClick(p)}
                  >
                    <div className="result-title">{p.title}</div>
                    <div className="result-url">{p.url}</div>
                  </li>
                );
              })}
            </ul>
          ) : (
            <div className="status-message">No pages found.</div>
          )}
        </div>
      </div>
    );
    return ReactDOM.createPortal(content, document.body);
  };

  return (
    <div className="cluster-container">
      <div className="cluster-grid">
        {clusters.length > 0 &&
          Array.from({ length: Math.min(clusterCount, clusters.length) }).map((_, i) => {
            const clusterData = isRefreshing ? undefined : effectiveClusters[i];
            return (
              <ClusterSquare
                key={`cluster-${i}`}
                cluster={clusterData}
                onClick={handleClusterClick}
              />
            );
          })}
      </div>
      {renderExpandedView()}
    </div>
  );
};

export default ClusterContainer;

==========================================
FILE: src/components/ClusterSquare.css
==========================================

.cluster-square {
  width: 100%;
  aspect-ratio: 2 / 1; /* Twice as wide as tall */
  border-radius: 12px;
  background-color: transparent;
  padding: 12px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s ease;
  border: 1px solid var(--border-color, rgba(0, 0, 0, 0.3));
  position: relative;
  overflow: hidden;
}

/* Hover state */
.cluster-square:hover {
  border-color: var(--border-hover-color, rgba(0, 0, 0, 0.5));
  box-shadow: 0 0 20px var(--shadow-color, rgba(0, 0, 0, 0.2));
}

/* Focus state for accessibility */
.cluster-square:focus {
  outline: none;
  border-color: var(--border-focus-color, rgba(0, 0, 0, 0.8));
  box-shadow: 0 0 25px var(--shadow-focus-color, rgba(0, 0, 0, 0.25));
}

/* Content container */
.cluster-content {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: center;
}

.cluster-title {
  margin: 0;
  font-size: 0.9rem;
  font-weight: 600;
  color: var(--text-color, #000);
  line-height: 1.3;
}

.cluster-info {
  font-size: 0.75rem;
  color: var(--text-secondary, rgba(0, 0, 0, 0.6));
}

/* Empty state styling */
.empty-state {
  opacity: 0.7;
}

.empty-state p {
  margin: 0;
  font-size: 0.85rem;
  font-style: italic;
  color: var(--text-secondary, rgba(0, 0, 0, 0.6));
}

/* Loading state styling */
.cluster-square.loading {
  cursor: default;
  position: relative;
}

/* Center the loading dots as a group */
.dots-container {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 12px;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 9999;
  margin: 0;
  padding: 0;
}

/* Unified dot styling (removes .cluster-dot duplication) */
.dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background-color: var(--text-color, #000);
  animation: pulse 2s infinite ease-in-out;
  display: inline-block;
}

/* Delay animations for a staggered effect */
.dot:nth-child(2) {
  animation-delay: 0.3s;
}
.dot:nth-child(3) {
  animation-delay: 0.6s;
}

@keyframes pulse {
  0%, 100% {
    opacity: 0.8;
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(1.2);
  }
}

/* Dark mode adjustments */
@media (prefers-color-scheme: dark) {
  .cluster-square {
    border-color: var(--border-color, rgba(255, 255, 255, 0.3));
  }
  .cluster-square:hover {
    border-color: var(--border-hover-color, rgba(255, 255, 255, 0.5));
    box-shadow: 0 0 20px var(--shadow-color, rgba(255, 255, 255, 0.2));
  }
  .cluster-square:focus {
    border-color: var(--border-focus-color, rgba(255, 255, 255, 0.8));
    box-shadow: 0 0 25px var(--shadow-focus-color, rgba(255, 255, 255, 0.25));
  }
  .cluster-title {
    color: var(--text-color, #fff);
  }
  .cluster-info,
  .empty-state p {
    color: var(--text-secondary, rgba(255, 255, 255, 0.6));
  }
  .dot {
    background-color: var(--text-color, #fff);
  }
}

==========================================
FILE: src/components/ClusterSquare.tsx
==========================================

import React from 'react';
import './ClusterSquare.css';
import { ClusterSuggestion } from '../types';

interface ClusterSquareProps {
  cluster?: ClusterSuggestion;
  onClick: (cluster?: ClusterSuggestion) => void;
}

/**
 * Displays a cluster's label or a loading indicator if cluster data is undefined.
 */
const ClusterSquare: React.FC<ClusterSquareProps> = ({ cluster, onClick }) => {
  const isLoading = !cluster;

  const handleClick = () => {
    if (!isLoading) {
      onClick(cluster);
    }
  };

  const handleKeyDown: React.KeyboardEventHandler<HTMLDivElement> = (e) => {
    if (!isLoading && (e.key === 'Enter' || e.key === ' ')) {
      e.preventDefault();
      handleClick();
    }
  };

  return (
    <div
      className={`cluster-square ${isLoading ? 'loading' : ''}`}
      onClick={isLoading ? undefined : handleClick}
      role="button"
      tabIndex={isLoading ? -1 : 0}
      aria-label={isLoading ? 'Loading cluster content' : `View pages in ${cluster?.label}`}
      onKeyDown={handleKeyDown}
    >
      {isLoading ? (
        <div className="dots-container" aria-hidden="true">
          <span className="dot"></span>
          <span className="dot"></span>
          <span className="dot"></span>
        </div>
      ) : (
        <div className="cluster-content">
          <h3 className="cluster-title">{cluster?.label}</h3>
          {/* If desired, show additional info like page_count or top_pages here */}
        </div>
      )}
    </div>
  );
};

export default ClusterSquare;

==========================================
FILE: src/components/NewTabSearchBar.css
==========================================

/* src/components/NewTabSearchBar.css */

/* 
   Container that wraps everything (search input + results).
   Now fully contained within parent wrapper that handles positioning.
*/
.search-container {
    width: 100%; /* Fill the parent wrapper */
    background-color: transparent;
    border-radius: 12px;
    padding: 16px 20px;
    border: 1px solid var(--border-color);
    transition: all 0.3s ease;
    position: relative; /* to contain absolutely positioned elements if needed */
    box-sizing: border-box; /* Ensure padding is included in width calculation */
    text-align: left; /* Explicit text alignment for input */
  }
  
  /* Hover & focus states */
  .search-container:hover {
    border-color: var(--border-hover-color);
    box-shadow: 0 0 20px var(--shadow-color);
  }
  .search-container:focus-within {
    border-color: var(--border-focus-color);
    box-shadow: 0 0 25px var(--shadow-focus-color);
  }
  
  /* The top bar with the icon + input + spinner */
  .search-bar-inner-container {
    display: flex;
    align-items: center;
    gap: 16px;
    width: 100%;
    position: relative;
    box-sizing: border-box; /* Consistent box model */
    margin-bottom: 8px;
  }
  
  /* Icon wrapper */
  .icon-wrapper {
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-color);
    cursor: default;
    padding: 8px;
    border-radius: 50%;
    transition: all 0.2s ease;
  }
  /* Make clickable if we have toggles */
  .icon-wrapper.clickable {
    cursor: pointer;
  }
  
  .icon-wrapper.clickable:hover {
    opacity: 0.8;
    transform: scale(1.1);
  }
  
  /* The search input */
  .search-input {
    background: transparent;
    border: none;
    color: var(--text-color);
    font-size: 18px;
    font-family: 'Cabinet Grotesk', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    line-height: 28px;
    width: 100%;
    padding: 0;
    margin: 0;
    outline: none;
  }
  .search-input::placeholder {
    color: var(--text-color);
    opacity: 0.7;
  }
  
  /* Spinner wrapper + spinner */
  .spinner-wrapper {
    margin-right: 8px;
    display: flex;
    align-items: flex-end;
  }
  
  @keyframes spin {
    0%   { transform: rotate(0deg);   }
    100% { transform: rotate(360deg); }
  }
  .spinner {
    box-sizing: border-box;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    border: 2px solid transparent;
    border-top-color: var(--text-color);
    border-left-color: var(--text-color);
    border-right-color: var(--text-color);
    animation: spin 0.8s linear infinite;
  }
  
  /* Search mode indicator (semantic vs quick launch) */
  .search-mode-indicator {
    margin-top: 8px;
    text-align: center;
    color: var(--text-secondary);
    font-size: 12px;
    font-style: italic;
    opacity: 0.7;
    transition: opacity 0.3s ease;
  }
  .search-mode-indicator.hidden {
    display: none;
    opacity: 0;
  }
  
  /* Results list below the input */
  .results-list {
    margin: 0;
    padding: 0;
    list-style: none;
    max-height: calc(3 * 72px);
    overflow: hidden;
  }
  
  .results-header {
    padding: 8px 12px;
    font-size: 14px;
    font-style: italic;
    color: var(--text-secondary);
    margin-bottom: 4px;
    text-align: center;
  }
  
  /* Results header divider line */
  .results-header-divider {
    border-bottom: 1px solid var(--border-color);
    margin: 0 0 4px 0;
  }
  
  .result-item {
    padding: 12px;
    cursor: pointer;
    transition: background-color 0.2s ease;
    border: none;
    border-left: 3px solid transparent;
  }
  .result-item:hover {
    background-color: var(--item-hover-bg);
  }
  .result-item.selected {
    background-color: var(--item-hover-bg);
    border-left: 3px solid var(--border-focus-color);
    padding-left: 9px; /* 12px - 3px border */
  }
  
  /* Title, URL, explanation */
  .result-title {
    font-size: 16px;
    font-weight: 500;
    color: var(--text-primary);
    margin-bottom: 4px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    display: flex;
    align-items: center;
  }
  .result-url {
    font-size: 12px;
    color: var(--text-secondary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    padding-left: 24px; /* Align with the title text after favicon */
  }
  .favicon {
    display: inline-block;
    width: 16px;
    height: 16px;
    margin-right: 8px;
    flex-shrink: 0;
  }
  /* Add styles for favicon error states */
  .favicon.error {
    opacity: 0.4;
  }
  .result-explanation {
    font-size: 12px;
    color: var(--text-secondary);
    margin-top: 4px;
    line-height: 1.4;
    opacity: 0.9;
    font-style: italic;
  }
  .explanation-label {
    font-weight: 600;
    font-style: normal;
  }
  
  /* Status messages (searching, no-results, etc.) */
  .status-message {
    text-align: center;
    padding: 10px 12px;
    color: var(--text-secondary);
    min-height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: opacity 0.2s ease;
    border-radius: 8px;
    margin: 4px 0;
  }
  .status-message.searching {
    font-size: 14px;
    font-style: italic;
  }
  .status-message.no-results {
    font-size: 14px;
    font-style: italic;
    color: var(--text-secondary);
  }

==========================================
FILE: src/components/NewTabSearchBar.tsx
==========================================

import React, { useRef, useState, useEffect } from 'react';
import type { KeyboardEvent as ReactKeyboardEvent, WheelEvent as ReactWheelEvent } from 'react';
import { useBackgroundSearch } from '../hooks/useBackgroundSearch';
import { SearchResult } from '../types';
import Favicon from '../utils/faviconUtils';
import './NewTabSearchBar.css';

/** Small Dory logo component */
const DoryLogo = ({ size = 24 }: { size?: number }) => (
  <svg width={size} height={size} viewBox="0 0 576 512">
    <path
      fill="#74d6ff"
      d="M180.5 141.5C219.7 108.5 272.6 80 336 80s116.3 28.5 155.5 61.5c39.1 33 66.9 72.4 81 99.8c4.7 9.2 4.7 20.1 0 29.3c-14.1 27.4-41.9 66.8-81 99.8C452.3 403.5 399.4 432 336 432s-116.3-28.5-155.5-61.5c-16.2-13.7-30.5-28.5-42.7-43.1L48.1 379.6c-12.5 7.3-28.4 5.3-38.7-4.9S-3 348.7 4.2 336.1L50 256 4.2 175.9c-7.2-12.6-5-28.4 5.3-38.6s26.1-12.2 38.7-4.9l89.7 52.3c12.2-14.6 26.5-29.4 42.7-43.1zM448 256a32 32 0 1 0 -64 0 32 32 0 1 0 64 0z"
    />
  </svg>
);

interface NewTabSearchBarProps {
  onSearchStateChange?: (isSearchActive: boolean) => void;
}

const NewTabSearchBar: React.FC<NewTabSearchBarProps> = ({ onSearchStateChange }) => {
  const { searchLocal, searchSemantic, trackResultClick } = useBackgroundSearch();

  const [inputValue, setInputValue] = useState('');
  const [isSearching, setIsSearching] = useState(false);
  const [localResults, setLocalResults] = useState<SearchResult[]>([]);
  const [isSemanticSearching, setIsSemanticSearching] = useState(false);
  const [semanticResults, setSemanticResults] = useState<SearchResult[]>([]);
  const [semanticError, setSemanticError] = useState<Error | null>(null);

  const [displayMode, setDisplayMode] = useState<'local' | 'semantic'>('local');
  const [selectedIndex, setSelectedIndex] = useState(-1);
  const [startIndex, setStartIndex] = useState(0); // For showing 3 results at a time
  const [lastKeystrokeTime, setLastKeystrokeTime] = useState(Date.now());

  const searchInputRef = useRef<HTMLInputElement>(null);

  // Focus the search bar globally if '/' pressed
  useEffect(() => {
    const handleGlobalKeyDown = (e: globalThis.KeyboardEvent) => {
      const tag = document.activeElement?.tagName;
      if (e.key === '/' && tag !== 'INPUT' && tag !== 'TEXTAREA') {
        e.preventDefault();
        searchInputRef.current?.focus();
      }
    };
    document.addEventListener('keydown', handleGlobalKeyDown);
    return () => document.removeEventListener('keydown', handleGlobalKeyDown);
  }, []);

  // When user types, reset lastKeystrokeTime and revert to local search
  useEffect(() => {
    setLastKeystrokeTime(Date.now());
    if (displayMode === 'semantic') setDisplayMode('local');
  }, [inputValue]);

  // Decide which results to display and whether they're loading
  const currentResults = displayMode === 'semantic' ? semanticResults : localResults;
  const currentLoading = displayMode === 'semantic' ? isSemanticSearching : isSearching;

  // Visible items for the results list
  const visibleResults = currentResults.slice(startIndex, startIndex + 3);
  const maxStartIndex = Math.max(0, currentResults.length - 3);

  // Reset selection when the result set changes
  useEffect(() => {
    setSelectedIndex(currentResults.length > 0 ? 0 : -1);
    setStartIndex(0);
  }, [currentResults]);

  // Notify parent about whether the search UI is active (>=2 chars)
  const isSearchActive = inputValue.trim().length >= 2;
  useEffect(() => {
    onSearchStateChange?.(isSearchActive);
  }, [isSearchActive, onSearchStateChange]);

  // Handler for text changes -> local search
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setInputValue(value);
    setDisplayMode('local');

    if (value.trim().length >= 2) {
      setIsSearching(true);
      searchLocal(value)
        .then(results => {
          setLocalResults(results);
          setIsSearching(false);
        })
        .catch(err => {
          console.error('[NewTabSearchBar] Local search error:', err);
          setLocalResults([]);
          setIsSearching(false);
        });
    } else {
      setLocalResults([]);
    }
  };

  // Semantic search
  const performSemanticSearch = (query: string) => {
    if (!query.trim()) return;
    setIsSemanticSearching(true);
    setSemanticError(null);
    searchSemantic(query)
      .then(results => {
        setSemanticResults(results);
        setIsSemanticSearching(false);
      })
      .catch(err => {
        console.error('[NewTabSearchBar] Semantic search error:', err);
        setSemanticError(err instanceof Error ? err : new Error(String(err)));
        setSemanticResults([]);
        setIsSemanticSearching(false);
      });
  };

  // Navigate to a result URL, track the click
  const navigateToResult = (result: SearchResult) => {
    const idx = currentResults.findIndex(r => r.id === result.id);
    trackResultClick(result.id || result.pageId || '', idx, result.url, inputValue);
    window.open(result.url, '_blank');
  };

  // Handle user hitting Enter, Escape, or arrow keys in the input
  const onInputKeyDown = (e: ReactKeyboardEvent<HTMLInputElement>) => {
    const length = currentResults.length;
    if (e.key === 'ArrowDown' && length > 0) {
      e.preventDefault();
      const newIdx = selectedIndex < length - 1 ? selectedIndex + 1 : 0;
      setSelectedIndex(newIdx);
      if (newIdx >= startIndex + 3) {
        setStartIndex(Math.min(newIdx - 2, maxStartIndex));
      } else if (newIdx < startIndex) {
        setStartIndex(0);
      }
    } else if (e.key === 'ArrowUp' && length > 0) {
      e.preventDefault();
      const newIdx = selectedIndex > 0 ? selectedIndex - 1 : length - 1;
      setSelectedIndex(newIdx);
      if (newIdx < startIndex) {
        setStartIndex(newIdx);
      } else if (newIdx === length - 1) {
        setStartIndex(maxStartIndex);
      }
    } else if (e.key === 'Escape') {
      setSelectedIndex(-1);
    } else if (e.key === 'Enter') {
      // If Ctrl/Cmd+Enter, do semantic search
      if ((e.ctrlKey || e.metaKey) && inputValue.trim()) {
        performSemanticSearch(inputValue);
        setDisplayMode('semantic');
        return;
      }
      // Otherwise, navigate if there's a selection
      if (selectedIndex >= 0 && selectedIndex < length) {
        e.preventDefault();
        navigateToResult(currentResults[selectedIndex]);
      }
    }
  };

  // Handle scrolling in the results list
  const handleScroll = (e: ReactWheelEvent<HTMLUListElement>) => {
    e.preventDefault();
    if (e.deltaY > 0 && startIndex < maxStartIndex) {
      setStartIndex(s => Math.min(s + 1, maxStartIndex));
    } else if (e.deltaY < 0 && startIndex > 0) {
      setStartIndex(s => Math.max(s - 1, 0));
    }
  };

  // Determine UI states
  const timeSinceKeystroke = Date.now() - lastKeystrokeTime;
  const debounceElapsed = timeSinceKeystroke > 1000;
  const showResults = isSearchActive && currentResults.length > 0 && !currentLoading;
  const showSearching = isSearchActive && currentLoading;
  const showNoResults = isSearchActive && currentResults.length === 0 && !currentLoading && debounceElapsed;

  return (
    <div className="search-container">
      <div className="search-bar-inner-container">
        <div className="icon-wrapper" title="Dory">
          <DoryLogo size={22} />
        </div>
        <input
          ref={searchInputRef}
          type="text"
          className="search-input"
          placeholder="Find what you forgot..."
          value={inputValue}
          onChange={handleInputChange}
          onKeyDown={onInputKeyDown}
        />
        {(isSearching || isSemanticSearching) && (
          <div className="spinner-wrapper">
            <div className="spinner" />
          </div>
        )}
      </div>

      {showResults && (
        <>
          <div className="results-header">
            {displayMode === 'semantic' ? 'Semantic Engine Results' : 'Quick Launch Results'}
          </div>
          <ul className="results-list" onWheel={handleScroll}>
            {visibleResults.map((item, idx) => {
              const actualIndex = startIndex + idx;
              return (
                <li
                  key={item.id}
                  className={`result-item ${selectedIndex === actualIndex ? 'selected' : ''}`}
                  onClick={() => navigateToResult(item)}
                  onMouseEnter={() => setSelectedIndex(actualIndex)}
                >
                  <div className="result-title">
                    <Favicon url={item.url} />
                    {item.title}
                  </div>
                  <div className="result-url">{item.url}</div>
                  {item.explanation && item.source === 'semantic' && (
                    <div className="result-explanation">
                      <span className="explanation-label">Why: </span>{item.explanation}
                    </div>
                  )}
                </li>
              );
            })}
          </ul>
        </>
      )}

      {showSearching && (
        <div className="status-message searching">
          {displayMode === 'semantic' ? 'Searching semantic engine...' : 'Searching quick launcher...'}
        </div>
      )}

      {showNoResults && (
        <div className="status-message no-results">
          {displayMode === 'semantic'
            ? 'No results from semantic engine'
            : 'No results found in quick launcher'}
        </div>
      )}
    </div>
  );
};

export default NewTabSearchBar;

==========================================
FILE: src/components/ThemeToggle.css
==========================================

/* src/pages/newtab/ThemeToggle.css */

.theme-toggle {
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 1px solid var(--border-color);
    background: transparent;
    cursor: pointer;
    transition: all 0.3s ease;
    padding: 0;
    z-index: 1000;
    color: var(--text-color);
  }
  
  /* Hover state */
  .theme-toggle:hover {
    transform: scale(1.1);
    border-color: var(--border-focus-color);
  }
  
  /* Focus state */
  .theme-toggle:focus {
    outline: none;
    box-shadow: 0 0 0 2px var(--border-focus-color);
  }

==========================================
FILE: src/components/ThemeToggle.tsx
==========================================

/**
 * @file ThemeToggle.tsx
 * 
 * A toggle button component for switching between light and dark mode
 * Uses the background API via useBackgroundPreferences
 */

import React from 'react';
import { FiSun, FiMoon } from 'react-icons/fi';
import useBackgroundPreferences from '../hooks/useBackgroundPreferences';
import './ThemeToggle.css';

const ThemeToggle: React.FC = () => {
  const { isDarkMode, toggleTheme } = useBackgroundPreferences();

  return (
    <button
      onClick={toggleTheme}
      aria-label={isDarkMode ? 'Switch to light mode' : 'Switch to dark mode'}
      title={isDarkMode ? 'Switch to light mode' : 'Switch to dark mode'}
      className="theme-toggle"
    >
      {isDarkMode ? <FiSun size={20} /> : <FiMoon size={20} />}
    </button>
  );
};

export default ThemeToggle;

==========================================
FILE: src/config.ts
==========================================

/**
 * @file config.ts
 * 
 * Centralized configuration for API endpoints and constants
 */

// Debug flags
export const DEBUG = process.env.NODE_ENV !== 'production';

// API Configuration
export const API_BASE_URL = process.env.API_BASE_URL || 'https://dory-backend-e18a6624326d.herokuapp.com';

// OAuth Configuration
export const GOOGLE_CLIENT_ID = process.env.VITE_GOOGLE_OAUTH_CLIENT_ID || '';

// Endpoint Groups
export const AUTH_ENDPOINTS = {
  ME: '/api/auth/me',
  TOKEN: '/api/auth/token',
  REFRESH: '/api/auth/refresh',
  LOGOUT: '/api/auth/logout',
};

export const COLD_STORAGE_ENDPOINTS = {
  BASE: '/api/cold-storage',
  PAGES: '/api/cold-storage/pages',
  VISITS: '/api/cold-storage/visits',
  SESSIONS: '/api/cold-storage/sessions',
  SEARCH_CLICKS: '/api/cold-storage/search-clicks'
};

export const CONTENT_ENDPOINTS = {
  CONTENT: '/api/content'
};

export const CLUSTERING_ENDPOINTS = {
  SUGGESTIONS: '/api/clustering/suggestions'
};

export const SEARCH_ENDPOINTS = {
  SEMANTIC: '/api/search/semantic'
};

// Search Configuration Constants are defined lower in the file

// Storage Keys
export const STORAGE_KEYS = {
  AUTH_STATE: 'authState',
  LAST_SYNC_KEY: 'lastColdStorageSync',
  CIRCUIT_BREAKER_KEY: 'coldStorageSyncCircuitBreaker',
  TELEMETRY_KEY: 'coldStorageSyncTelemetry',
  CLUSTER_HISTORY_KEY: 'clusterHistory',
  PREFERRED_THEME_KEY: 'preferredTheme'
};



// Cold Storage Sync Configuration
export const COLD_STORAGE_CONFIG = {
  SYNC_INTERVAL_MINUTES: 5,
  BATCH_SIZE: 500,
  MAX_CONSECUTIVE_FAILURES: 3,
  CIRCUIT_RESET_TIME_MS: 30 * 60 * 1000, // 30 minutes
};

// URL Filtering Configuration
export const URL_FILTER_CONFIG = {
  // URL schemes to ignore
  IGNORED_URL_SCHEMES: [
    'about:', 'data:', 'blob:', 'javascript:', 'mailto:', 'tel:'
  ],
  
  // Generic titles to filter out
  GENERIC_TITLES: [
    '', 'untitled'
  ],
  
  // Google search domains to filter
  GOOGLE_SEARCH_DOMAINS: [
    'www.google.com',
    'www.google.co.uk',
    'www.google.ca',
    'www.google.com.au',
    'www.google.de',
    'www.google.fr',
    'www.google.es',
    'www.google.it',
    'www.google.co.jp',
    'www.google.com.br',
  ],
  
  // Authentication path endings to filter
  AUTH_PATH_ENDINGS: [
    // Login/Signup
    '/login', '/signin', '/signup', '/auth', '/authenticate',
    '/sso', '/oauth', '/account/login', '/account/signin', '/login.php', '/login.aspx',
    // Logout
    '/logout', '/signout', '/account/logout', '/account/signout',
    // Password Reset
    '/password/reset', '/forgot-password', '/reset-password', '/account/reset'
  ],
  
  // Authentication title keywords to filter
  AUTH_TITLE_KEYWORDS: [
    // Login/Signup
    'log in', 'login', 'sign in', 'signin', 'sign up', 'signup',
    'authenticate', 'authentication', 'account access', 'access account',
    // Logout
    'log out', 'logout', 'sign out', 'signout',
    // Password Reset
    'reset password', 'forgot password',
    // Error Pages
    '404', 'not found', 'error', 'server error', 'oops', 'problem loading page'
  ]
};

// Dory Ranking Configuration
export const RANKING_CONFIG = {
  // BM25 parameters
  BM25: {
    K1: 1.2,
    B_TITLE: 0.75,
    B_URL: 0.75,
    WEIGHT_TITLE: 1.0,
    WEIGHT_URL: 2.0,
  },
  
  // Time decay half-lives in seconds
  TIME_DECAY: {
    SHORT_TERM: 7200,  // 2-hour half-life
    MEDIUM_TERM: 86400, // 1-day half-life
    LONG_TERM: 604800,  // 7-day half-life
  },
  
  // Recency weighting factors
  RECENCY_WEIGHTS: {
    SHORT_TERM: 1.0,
    MEDIUM_TERM: 0.5,
    LONG_TERM: 0.2,
  },
  
  // Substring matching bonus weights
  SUBSTRING_BONUS: {
    URL_PREFIX: 2.0,
    URL_CONTAINS: 1.0,
    TITLE_PREFIX: 1.0,
    TITLE_CONTAINS: 0.5,
  }
};

// Content Extraction Configuration
export const USE_FIT_MARKDOWN = true;
export const QUEUE_CONFIG = {
  // Maximum number of retries for processing a URL
  MAX_RETRIES: 3,
  
  // Delay between retries (in milliseconds)
  RETRY_DELAY_MS: 3000,
  
  // Maximum time to process a single URL (in milliseconds)
  PROCESSING_TIMEOUT_MS: 60000,

  // Maximum time to wait for DOM to settle (in milliseconds)
  DOM_IDLE_TIMEOUT_MS: 7000,

  // How long to wait after last mutation to declare DOM "idle" (in milliseconds)
  DOM_IDLE_CHECK_DELAY_MS: 500
} as const;

// Search Configuration
export const SEARCH_CONFIG = {
  // Debounce delay for search inputs (in milliseconds)
  DEBOUNCE_MS: 150,
  SEARCH_DEBOUNCE_MS: 300, // For the refactored components
  
  // Minimum length for a query to trigger search
  MIN_QUERY_LENGTH: 2,
  
  // Maximum number of history results to request
  MAX_HISTORY_RESULTS: 100,
  
  // Maximum number of local results to show
  MAX_LOCAL_RESULTS: 10,
  
  // Maximum number of semantic results to show
  MAX_SEMANTIC_RESULTS: 20
} as const;



==========================================
FILE: src/content/activityTracker.ts
==========================================

/**
 * @file activityTracker.ts
 * Tracks user activity (tab visibility) and notifies the background script.
 */

import { getBackgroundAPI } from '../utils/comlinkSetup';
import type { BackgroundAPI } from '../background/api';

/** Timestamp of the last time the page became active. */
let lastActiveTime: number | null = document.hidden ? null : Date.now();

/**
 * Reports activity data to the background script using Comlink.
 */
async function notifyActivity(isActive: boolean, duration: number): Promise<void> {
  try {
    const api = getBackgroundAPI<BackgroundAPI>();
    const activity = await api.activity;
    await activity.reportActivity({
      isActive,
      pageUrl: window.location.href,
      duration,
    });
  } catch (err) {
    console.error('[ActivityTracker] Error reporting activity:', err);
  }
}

/**
 * Handles visibility changes (document.hidden).
 */
function handleVisibilityChange(): void {
  if (document.hidden && lastActiveTime !== null) {
    // Transitioning from active to inactive
    const now = Date.now();
    const diffSec = (now - lastActiveTime) / 1000;
    lastActiveTime = null;
    notifyActivity(false, diffSec);
  } else if (!document.hidden) {
    // Transitioning from inactive to active
    lastActiveTime = Date.now();
    notifyActivity(true, 0);
  }
}

/** Listen for visibility changes. */
document.addEventListener('visibilitychange', handleVisibilityChange);

/**
 * Handle pagehide (for when the user actually leaves the page,
 * not just bfcache).
 */
window.addEventListener('pagehide', event => {
  if (!event.persisted && lastActiveTime !== null) {
    const now = Date.now();
    const diffSec = (now - lastActiveTime) / 1000;
    notifyActivity(false, diffSec);
    lastActiveTime = null;
  }
});

==========================================
FILE: src/content/contentExtractor.ts
==========================================

/**
 * @file contentExtractor.ts
 * Exposes an API to extract content from the current page, via Comlink.
 */

import { exposeBackgroundAPI } from '../utils/comlinkSetup';
import { DefaultMarkdownGenerator } from '../html2text/markdownGenerator';
import { PruningContentFilter } from '../html2text/content_filter_strategy';
import { USE_FIT_MARKDOWN, QUEUE_CONFIG } from '../config';
import { ExtractedContent } from '../types';

const {
  DOM_IDLE_TIMEOUT_MS = 10000,
  DOM_IDLE_CHECK_DELAY_MS = 1000,
  PROCESSING_TIMEOUT_MS = 30000,
  RETRY_DELAY_MS = 2000,
  MAX_RETRIES = 3,
} = QUEUE_CONFIG;

let extractionTimeoutId: number | null = null;

const contentAPI = {
  async extractContent(options: { retryCount?: number } = {}): Promise<ExtractedContent> {
    const { retryCount = 0 } = options;
    setupExtractionTimeout();

    try {
      await waitForDomIdle();
      const html = document.body?.innerHTML || '';
      if (!html) throw new Error('Empty document');

      const filter = new PruningContentFilter(
        undefined,
        5,             // Min blocks
        'dynamic',     // Strategy
        0.5,           // Threshold
        'english'      // Language
      );

      const mdGen = new DefaultMarkdownGenerator(undefined, { body_width: 80 });
      const result = mdGen.generateMarkdown(html, location.href, { body_width: 80 }, filter, true);

      const sourceMarkdown = USE_FIT_MARKDOWN
        ? result.fitMarkdown
        : result.markdownWithCitations || result.rawMarkdown;

      if (!sourceMarkdown) throw new Error('Markdown generation failed');

      clearExtractionTimeout();

      return {
        title: document.title || 'Untitled',
        url: location.href,
        markdown: sourceMarkdown,
        timestamp: Date.now(),
        metadata: { language: 'en' },
      };
    } catch (err) {
      if (retryCount < MAX_RETRIES) {
        await delay(RETRY_DELAY_MS);
        return this.extractContent({ retryCount: retryCount + 1 });
      }
      clearExtractionTimeout();
      throw err;
    }
  },

  isPageReady(): boolean {
    return document.readyState === 'complete';
  },
};

function setupExtractionTimeout() {
  clearExtractionTimeout();
  extractionTimeoutId = window.setTimeout(() => {
    console.warn('[ContentExtractor] Extraction timed out');
    extractionTimeoutId = null;
  }, PROCESSING_TIMEOUT_MS);

  window.addEventListener('pagehide', ev => {
    if (!ev.persisted) clearExtractionTimeout();
  });
}

function clearExtractionTimeout() {
  if (extractionTimeoutId !== null) {
    clearTimeout(extractionTimeoutId);
    extractionTimeoutId = null;
  }
}

/**
 * Waits for the DOM to remain idle for a short period, or times out.
 */
async function waitForDomIdle(): Promise<void> {
  return new Promise(resolve => {
    let observer: MutationObserver | null = null;
    let lastMutation = Date.now();

    const checkIdle = () => {
      if (Date.now() - lastMutation >= DOM_IDLE_CHECK_DELAY_MS) {
        observer?.disconnect();
        resolve();
      }
    };

    try {
      observer = new MutationObserver(() => (lastMutation = Date.now()));
      observer.observe(document.body, { childList: true, attributes: true, characterData: true, subtree: true });
    } catch {
      // If MutationObserver fails, proceed immediately
      resolve();
    }

    const idleInterval = setInterval(checkIdle, Math.min(DOM_IDLE_CHECK_DELAY_MS / 2, 1000));
    const fallbackTimer = setTimeout(() => {
      observer?.disconnect();
      resolve();
    }, DOM_IDLE_TIMEOUT_MS);

    // Cleanup once we're done
    setTimeout(() => clearInterval(idleInterval), DOM_IDLE_TIMEOUT_MS + 200);
    setTimeout(() => clearTimeout(fallbackTimer), DOM_IDLE_TIMEOUT_MS + 200);
  });
}

function delay(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// Expose the contentAPI via Comlink using the utility from comlinkSetup

if (typeof chrome !== 'undefined' && chrome.runtime) {
  exposeBackgroundAPI(contentAPI);
  console.log('[ContentExtractor] Ready and exposing API via Comlink.');
}

==========================================
FILE: src/content/globalSearch.tsx
==========================================

/**
 * @file globalSearch.tsx
 * Content script that, when triggered, shows a floating search overlay with React.
 * Uses Comlink for type-safe background API access with bidirectional communication.
 */

import React from 'react';
import { createRoot } from 'react-dom/client';
import SearchOverlay from '../pages/spotlight/SearchOverlay';
import '../pages/spotlight/spotlight.css';

// Comlink and background API imports
import * as Comlink from 'comlink';
import { getBackgroundAPI } from '../utils/comlinkSetup';
import type { BackgroundAPI } from '../background/api';
import type { ContentCommandAPI } from '../types';

console.log('[DORY] globalSearch.tsx loaded and initializing with Comlink...');

let overlayContainer: HTMLDivElement | null = null;
let styleSheet: HTMLStyleElement | null = null;
let rootElement: HTMLElement | null = null;
let reactRoot: any = null;
let previouslyFocusedElement: Element | null = null;

/**
 * Initialize background API and register this content script for command routing.
 * This establishes a bidirectional Comlink connection with the background API.
 */
async function initBackgroundAPI() {
  try {
    // Get the background API using Comlink
    const api = getBackgroundAPI<BackgroundAPI>();
    console.log('[DORY] Successfully connected to background API via Comlink');
    
    // Get current tab ID for registration
    const tabId = await getCurrentTabId();
    if (!tabId) {
      throw new Error('Could not determine current tab ID');
    }
    
    // Create the content command API implementation
    const commandHandler: ContentCommandAPI = {
      showSearchOverlay: async (action: 'show' | 'hide' | 'toggle'): Promise<boolean> => {
        console.log(`[DORY] Received command via Comlink: showSearchOverlay(${action})`);
        handleToggleOverlay(action);
        return true;
      }
    };
    
    // Create a message channel for background to communicate with content
    const { port1, port2 } = new MessageChannel();
    
    // Expose our command API on port1
    Comlink.expose(commandHandler, port1);
    
    // Send port2 to the background script
    const commands = await api.commands;
    const registered = await commands.registerCommandHandler(tabId, Comlink.transfer(port2, [port2]));
    
    if (registered) {
      console.log(`[DORY] Tab ${tabId} registered with background command service via Comlink`);
    } else {
      console.error(`[DORY] Failed to register tab ${tabId} with background command service`);
    }
    
    // No need for message listener anymore since we're using Comlink
    // Remove any existing listeners just to be safe
    try {
      chrome.runtime.onMessage.removeListener(function(message) {
        return message.type === 'SHOW_SEARCH_OVERLAY';
      });
    } catch (err) {
      // Ignore errors from removing non-existent listeners
    }
    
  } catch (error) {
    console.error('[DORY] Error initializing background API:', error);
  }
}

/**
 * Helper function to get the current tab ID
 * @returns Promise resolving to the current tab ID or undefined
 */
async function getCurrentTabId(): Promise<number | undefined> {
  return new Promise((resolve) => {
    try {
      chrome.runtime.sendMessage({ type: 'GET_CURRENT_TAB_ID' }, (response) => {
        if (chrome.runtime.lastError) {
          console.error('[DORY] Error getting tab ID:', chrome.runtime.lastError);
          resolve(undefined);
        } else {
          resolve(response?.tabId);
        }
      });
    } catch (error) {
      console.error('[DORY] Error requesting tab ID:', error);
      resolve(undefined);
    }
  });
}

/**
 * Handle overlay visibility command received from the background script.
 * @param action The action to perform ('show', 'hide', or 'toggle')
 */
/**
 * Handle overlay visibility command received via Comlink
 * @param action The action to perform ('show', 'hide', or 'toggle')
 */
function handleToggleOverlay(action: 'show' | 'hide' | 'toggle' = 'toggle'): void {
  console.log(`[DORY] Overlay command received via Comlink: ${action}`);
  
  if (action === 'hide' || (action === 'toggle' && overlayContainer)) {
    console.log('[DORY] Hiding overlay');
    hideSearchOverlay();
  } else if (action === 'show' || (action === 'toggle' && !overlayContainer)) {
    console.log('[DORY] Showing overlay');
    // Use async function and handle any errors
    showSearchOverlay().catch(err => {
      console.error('[DORY] Error showing search overlay:', err);
    });
  }
}

// Initialize right away
initBackgroundAPI();

// Also listen for keyboard shortcut directly in the content script
document.addEventListener('keydown', (e) => {
  // Handle Escape key to close the overlay when it's visible
  if (e.key === 'Escape' && overlayContainer) {
    hideSearchOverlay();
  }
});

async function showSearchOverlay(): Promise<void> {
  removeExistingOverlay();
  
  // Store the currently focused element to restore focus when we close
  previouslyFocusedElement = document.activeElement;

  // Create main container
  overlayContainer = document.createElement('div');
  overlayContainer.id = 'dory-search-overlay';
  
  // Get theme preference from background API
  let prefersDarkMode = false;
  try {
    // Get background API and preferences service
    const api = getBackgroundAPI<BackgroundAPI>();
    const preferences = await api.preferences;
    
    // Get theme from the preferences service
    const theme = await preferences.getTheme();
    
    if (theme === 'dark') {
      prefersDarkMode = true;
    } else if (theme === 'system') {
      // Check system preference
      prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
    }
    // For theme === 'light', prefersDarkMode remains false
    
    console.log(`[DORY] Using theme: ${theme} (dark mode: ${prefersDarkMode})`);
  } catch (err) {
    console.error('[DORY] Error getting theme from background API:', err);
    // Fall back to system preference
    prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
  }
  
  // Apply theme class
  if (prefersDarkMode) {
    overlayContainer.classList.add('dory-dark-theme');
  } else {
    overlayContainer.classList.add('dory-light-theme');
  }
  
  // Create style element
  styleSheet = document.createElement('style');
  styleSheet.textContent = `
    /* Load Cabinet Grotesk font */
    @font-face {
      font-family: 'Cabinet Grotesk';
      src: url(${chrome.runtime.getURL('fonts/Cabinet-Grotesk/CabinetGrotesk-Regular.otf')}) format('opentype');
      font-weight: 400;
      font-style: normal;
    }
    
    @font-face {
      font-family: 'Cabinet Grotesk';
      src: url(${chrome.runtime.getURL('fonts/Cabinet-Grotesk/CabinetGrotesk-Medium.otf')}) format('opentype');
      font-weight: 500;
      font-style: normal;
    }
    
    @font-face {
      font-family: 'Cabinet Grotesk';
      src: url(${chrome.runtime.getURL('fonts/Cabinet-Grotesk/CabinetGrotesk-Bold.otf')}) format('opentype');
      font-weight: 700;
      font-style: normal;
    }

    /* Overlay-specific positioning */
    #dory-search-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 999999;
      display: flex;
      justify-content: flex-end;
      align-items: flex-start;
      padding-top: 15vh;
      padding-right: 15vw;
      background-color: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(5px);
      font-family: 'Cabinet Grotesk', sans-serif;
      transition: opacity 0.2s ease-in-out;
      opacity: 0;
    }
    
    #dory-search-overlay.visible {
      opacity: 1;
    }
    
    #dory-search-container {
      width: 600px;
      max-width: 90%;
    }
    
    /* Spotlight-specific container */
    .spotlight-search {
      width: 100%;
      height: 100%;
    }

    /* ========== NewTabSearchBar.css for Content Script Context ========== */
    /* Container that wraps everything */
    .search-container {
      width: 100%; /* Fill the parent wrapper */
      background-color: transparent;
      border-radius: 12px;
      padding: 16px 20px;
      border: 1px solid var(--border-color);
      transition: all 0.3s ease;
      position: relative; /* to contain absolutely positioned elements if needed */
      box-sizing: border-box; /* Ensure padding is included in width calculation */
      text-align: left; /* Explicit text alignment for input */
    }
    
    /* Hover & focus states */
    .search-container:hover {
      border-color: var(--border-hover-color);
      box-shadow: 0 0 20px var(--shadow-color);
    }
    .search-container:focus-within {
      border-color: var(--border-focus-color);
      box-shadow: 0 0 25px var(--shadow-focus-color);
    }
    
    /* The top bar with the icon + input + spinner */
    .search-bar-inner-container {
      display: flex;
      align-items: center;
      gap: 16px;
      width: 100%;
      position: relative;
      box-sizing: border-box; /* Consistent box model */
      margin-bottom: 8px;
    }
    
    /* Results header divider line */
    .results-header-divider {
      border-bottom: 1px solid var(--border-color);
      margin: 0 0 4px 0; /* Keep original spacing to results */
    }
    
    /* Icon wrapper */
    .icon-wrapper {
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-color);
      cursor: default;
      padding: 8px;
      border-radius: 50%;
      transition: all 0.2s ease;
    }
    /* Make clickable if we have toggles */
    .icon-wrapper.clickable {
      cursor: pointer;
    }
    
    .icon-wrapper.clickable:hover {
      opacity: 0.8;
      transform: scale(1.1);
    }
    
    /* The search input */
    .search-input {
      background: transparent;
      border: none;
      color: var(--text-color);
      font-size: 18px;
      font-family: 'Cabinet Grotesk', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      line-height: 28px;
      width: 100%;
      padding: 0;
      margin: 0;
      outline: none;
    }
    .search-input::placeholder {
      color: var(--text-color);
      opacity: 0.7;
    }
    
    /* Spinner wrapper + spinner */
    .spinner-wrapper {
      margin-right: 8px;
      display: flex;
      align-items: flex-end;
    }
    
    @keyframes spin {
      0%   { transform: rotate(0deg);   }
      100% { transform: rotate(360deg); }
    }
    .spinner {
      box-sizing: border-box;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 2px solid transparent;
      border-top-color: var(--text-color);
      border-left-color: var(--text-color);
      border-right-color: var(--text-color);
      animation: spin 0.8s linear infinite;
    }
    
    /* Search mode indicator (semantic vs quick launch) */
    .search-mode-indicator {
      margin-top: 8px;
      text-align: center;
      color: var(--text-secondary);
      font-size: 12px;
      font-style: italic;
      opacity: 0.7;
      transition: opacity 0.3s ease;
    }
    .search-mode-indicator.hidden {
      display: none;
      opacity: 0;
    }
    
    /* Results list below the input */
    .results-list {
      margin: 0;
      padding: 0;
      list-style: none;
      max-height: calc(3 * 72px);
      overflow: hidden;
    }
    
    .results-header {
      padding: 2px 12px 4px 12px; /* Reduce top padding from 8px to 2px */
      font-size: 14px;
      font-style: italic;
      color: var(--text-secondary);
      margin-bottom: 0px; /* Reduce from 4px to 0px */
      text-align: center;
    }
    
    .result-item {
      padding: 12px;
      cursor: pointer;
      transition: background-color 0.2s ease;
      border: none;
      border-left: 3px solid transparent;
      border-radius: 12px;
    }
    .result-item:hover {
      background-color: var(--item-hover-bg);
    }
    .result-item.selected {
      background-color: var(--item-hover-bg);
      border-left: 3px solid var(--border-focus-color);
      padding-left: 9px; /* 12px - 3px border */
    }
    
    /* Title, URL, explanation */
    .result-title {
      font-size: 16px;
      font-weight: 500;
      color: var(--text-primary);
      margin-bottom: 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .result-url {
      font-size: 12px;
      color: var(--text-secondary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .result-explanation {
      font-size: 12px;
      color: var(--text-secondary);
      margin-top: 4px;
      line-height: 1.4;
      opacity: 0.9;
      font-style: italic;
    }
    .explanation-label {
      font-weight: 600;
      font-style: normal;
    }
    
    /* Status messages (searching, no-results, etc.) */
    .status-message {
      text-align: center;
      padding: 10px 12px;
      color: var(--text-secondary);
      min-height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: opacity 0.2s ease;
      border-radius: 8px;
      margin: 4px 0;
    }
    .status-message.searching {
      font-size: 14px;
      font-style: italic;
    }
    .status-message.no-results {
      font-size: 14px;
      font-style: italic;
      color: var(--text-secondary);
    }
    /* ========== END NewTabSearchBar.css styles ========== */
    
    /* Theme-specific overrides for content script environment */
    /* Light theme - for the search bar */
    .dory-light-theme .search-container {
      background-color: #ffffff !important;
      color: #000000 !important;
      border: 1px solid rgba(0, 0, 0, 0.3) !important;
      --border-color: rgba(0, 0, 0, 0.2);
      --border-hover-color: rgba(0, 0, 0, 0.2);
      --border-focus-color: rgba(0, 0, 0, 0.8);
      --shadow-color: rgba(0, 0, 0, 0.1);
      --shadow-focus-color: rgba(0, 0, 0, 0.2);
      --text-color: #000000;
      --text-primary: #000000;
      --text-secondary: #555555;
      --item-hover-bg: rgba(0, 0, 0, 0.05);
    }
    
    .dory-light-theme .search-input {
      color: #000000 !important;
    }
    
    .dory-light-theme .search-input::placeholder {
      color: rgba(0, 0, 0, 0.7) !important;
    }
    
    /* Dark theme - for the search bar */
    .dory-dark-theme .search-container {
      background-color: #000000 !important;
      color: #ffffff !important;
      border: 1px solid rgba(255, 255, 255, 0.3) !important;
      --border-color: rgba(255, 255, 255, 0.2);
      --border-hover-color: rgba(255, 255, 255, 0.2);
      --border-focus-color: rgba(255, 255, 255, 0.8);
      --shadow-color: rgba(0, 0, 0, 0.3);
      --shadow-focus-color: rgba(255, 255, 255, 0.2);
      --text-color: #ffffff;
      --text-primary: #ffffff;
      --text-secondary: #bbbbbb;
      --item-hover-bg: rgba(255, 255, 255, 0.05);
    }
    
    .dory-dark-theme .search-input {
      color: #ffffff !important;
    }
    
    .dory-dark-theme .search-input::placeholder {
      color: rgba(255, 255, 255, 0.7) !important;
    }
    
    /* Make sure background matches theme */
    .dory-light-theme .results-list {
      background-color: #ffffff !important;
    }
    
    .dory-dark-theme .results-list {
      background-color: #000000 !important;
    }
    
    /* Specific overrides for SearchOverlay in content script context */
    .dory-light-theme .spotlight-search[data-active="true"] .search-container {
      box-shadow: 0 0 35px rgba(0, 0, 0, 0.3) !important;
    }
    
    .dory-dark-theme .spotlight-search[data-active="true"] .search-container {
      box-shadow: 0 0 35px rgba(255, 255, 255, 0.2) !important;
    }
  `;
  document.head.appendChild(styleSheet);

  // Create container for the React app
  rootElement = document.createElement('div');
  rootElement.id = 'dory-search-container';
  overlayContainer.appendChild(rootElement);
  
  // Add to DOM
  document.body.appendChild(overlayContainer);
  
  // Render React component
  renderReactApp(rootElement);
  
  // Animate in
  setTimeout(() => {
    overlayContainer?.classList.add('visible');
  }, 10);
}

function removeExistingOverlay() {
  const existing = document.getElementById('dory-search-overlay');
  if (existing && existing.parentNode) {
    existing.parentNode.removeChild(existing);
  }
  
  // Clean up React root if it exists
  if (reactRoot) {
    try {
      reactRoot.unmount();
    } catch (err) {
      console.error('[DORY] Error unmounting React root:', err);
    }
    reactRoot = null;
  }
}

function hideSearchOverlay(): void {
  if (overlayContainer) {
    // Animate out
    overlayContainer.classList.remove('visible');
    
    // Wait for animation to complete before removing
    setTimeout(() => {
      if (overlayContainer) {
        overlayContainer.remove();
        overlayContainer = null;
      }
      
      if (styleSheet) {
        styleSheet.remove();
        styleSheet = null;
      }
      
      // Restore focus to the previously focused element
      if (previouslyFocusedElement && 'focus' in previouslyFocusedElement) {
        (previouslyFocusedElement as HTMLElement).focus();
      }
      previouslyFocusedElement = null;
    }, 200); // Match transition duration
  }
}

/**
 * Renders the SearchOverlay React component in the provided container.
 * Includes error handling and fallback UI.
 * 
 * @param container The DOM element to render the React component in
 */
function renderReactApp(container: HTMLElement): void {
  try {
    console.log('[DORY] Creating React root...');
    reactRoot = createRoot(container);
    
    // Initialize React context providers if needed
    console.log('[DORY] React root created, rendering SearchOverlay...');
    
    // Render our refactored SearchOverlay component that uses the background API
    reactRoot.render(
      <SearchOverlay onClose={hideSearchOverlay} />
    );
    
    console.log('[DORY] SearchOverlay rendered successfully');
  } catch (err: any) {
    console.error('[DORY] Error rendering React:', err);
    console.error('[DORY] Error details:', {
      message: err.message,
      stack: err.stack,
      name: err.name
    });
    
    // Provide a user-friendly error message
    container.innerHTML = `
      <div style="padding: 20px; text-align: center; color: #333; background-color: white; border-radius: 12px;">
        <h3 style="margin-top: 0;">DORY Search Error</h3>
        <p>There was an error loading the search overlay.</p>
        <p style="font-size: 12px; color: #777;">${err.message}</p>
      </div>`;
  }
} 

==========================================
FILE: src/db/DatabaseCore.ts
==========================================

/**
 * @file DatabaseCore.ts
 * 
 * Core database foundation for the Dory extension.
 * Provides a Dexie database implementation with user isolation
 * and centralized database instance management.
 */

import Dexie from 'dexie';
import {
  PageRecord,
  VisitRecord,
  EdgeRecord,
  BrowsingSession,
  EventRecord,
  MetadataRecord,
  DoryDatabaseTables
} from '../types';

/**
 * The main Dory database class.
 * Extends Dexie to provide a strongly-typed database with the tables we need.
 */
export class DoryDatabase extends Dexie implements DoryDatabaseTables {
  // Table declarations - these get their types from DoryDatabaseTables
  pages!: Dexie.Table<PageRecord, string>;
  visits!: Dexie.Table<VisitRecord, string>;
  edges!: Dexie.Table<EdgeRecord, number>;
  sessions!: Dexie.Table<BrowsingSession, number>;
  events!: Dexie.Table<EventRecord, number>;
  metadata!: Dexie.Table<MetadataRecord, string>;

  constructor(userId: string) {
    // Each user gets their own database
    super(`dory_${userId}`);
    
    // Database schema - using latest version only
    this.version(1).stores({
      pages: `
        pageId,
        url,
        domain,
        lastVisit,
        visitCount,
        personalScore,
        syncStatus,
        updatedAt
      `,
      edges: `
        edgeId,
        [fromPageId+toPageId+sessionId],
        fromPageId,
        toPageId,
        sessionId,
        timestamp,
        count,
        firstTraversal,
        lastTraversal,
        *isBackNavigation
      `,
      sessions: `
        sessionId,
        startTime,
        endTime,
        lastActivityAt,
        totalActiveTime,
        isActive
      `,
      visits: `
        visitId,
        pageId,
        sessionId,
        fromPageId,
        startTime,
        endTime,
        totalActiveTime,
        *isBackNavigation
      `,
      events: `
        eventId,
        operation,
        sessionId,
        timestamp,
        loggedAt
      `,
      metadata: `
        key,
        updatedAt
      `
    });
  }
}

/**
 * Central manager for database instances.
 * Handles multiple user databases and tracks the current active user.
 */
export class DatabaseManager {
  // Store database instances by user ID
  private static instances: Map<string, DoryDatabase> = new Map();
  private static currentUserId: string | null = null;
  
  /**
   * Get a database instance for a specific user
   * @param userId The user's ID
   * @returns A DoryDatabase instance for that user
   */
  static getUserDatabase(userId: string): DoryDatabase {
    if (!this.instances.has(userId)) {
      this.instances.set(userId, new DoryDatabase(userId));
    }
    return this.instances.get(userId)!;
  }
  
  /**
   * Get the database for the current user
   * @returns The current user's database, or null if no user is set
   */
  static getCurrentDatabase(): DoryDatabase | null {
    if (!this.currentUserId) return null;
    return this.getUserDatabase(this.currentUserId);
  }
  
  /**
   * Set the current active user
   * @param userId The user's ID
   */
  static setCurrentUser(userId: string): void {
    this.currentUserId = userId;
  }
  
  /**
   * Get the current user's ID
   * @returns The current user's ID, or null if not set
   */
  static getCurrentUserId(): string | null {
    return this.currentUserId;
  }
  
  /**
   * Close a user's database
   * @param userId The user's ID
   */
  static closeDatabase(userId: string): void {
    const db = this.instances.get(userId);
    if (db) {
      db.close();
      this.instances.delete(userId);
    }
  }
  
  /**
   * Close all database instances
   */
  static closeAllDatabases(): void {
    this.instances.forEach(db => db.close());
    this.instances.clear();
  }
}

/**
 * Initialize the database system
 * @returns A promise that resolves when initialization is complete
 */
export async function initializeDatabase(): Promise<void> {
  console.log('[DatabaseCore] Initializing database system...');
  
  try {
    // Get user data from storage
    const data = await chrome.storage.local.get(['user']);
    const userId = data.user?.id;
    
    // If we have a user, set them as current
    if (userId) {
      console.log(`[DatabaseCore] Setting current user: ${userId}`);
      DatabaseManager.setCurrentUser(userId);
      
      // Pre-initialize the database
      DatabaseManager.getUserDatabase(userId);
      
      // Mark initialization as complete
      dbInitializationComplete = true;
    } else {
      console.log('[DatabaseCore] No user found, database will be initialized when user logs in');
      dbInitializationComplete = false;
    }
    
    console.log('[DatabaseCore] Database system initialized');
  } catch (error) {
    console.error('[DatabaseCore] Failed to initialize database:', error);
    dbInitializationComplete = false;
    
    throw error;
  }
}

// Track initialization state
let dbInitializationComplete = false;

/**
 * Check if the database is initialized
 * @returns True if database initialization is complete
 */
export function isDatabaseInitialized(): boolean {
  return dbInitializationComplete;
}

// Export default object for convenience
export default {
  DoryDatabase,
  DatabaseManager,
  initializeDatabase,
  isDatabaseInitialized
};


==========================================
FILE: src/db/index.ts
==========================================

/**
 * @file index.ts
 * 
 * Barrel file for the database module.
 * Exports all database-related functionality.
 */

// Export everything from DatabaseCore
export * from './DatabaseCore';

// Export default object from DatabaseCore
export { default } from './DatabaseCore';


==========================================
FILE: src/db/repositories/EdgeRepository.ts
==========================================

/**
 * @file EdgeRepository.ts
 * 
 * Repository for working with navigation edges in the database.
 * Edges represent connections between pages, forming the navigation graph.
 */

import { DatabaseManager } from '../DatabaseCore';
import { EdgeRecord } from '../../types';
import { generateEdgeId } from '../../utils/idGenerator';

/**
 * Repository for managing navigation edges between pages
 */
export class EdgeRepository {
  /**
   * Create or update an edge between two pages
   * If an edge already exists in the same session, increments its count
   * Otherwise, creates a new edge
   * 
   * @param fromPageId The source page ID
   * @param toPageId The destination page ID
   * @param sessionId The session ID when this navigation occurred
   * @param timestamp When the navigation happened
   * @param isBackNavigation Whether this was a back/forward navigation
   * @returns The edge ID
   */
  async createOrUpdate(
    fromPageId: string,
    toPageId: string,
    sessionId: number,
    timestamp: number = Date.now(),
    isBackNavigation: boolean = false
  ): Promise<number> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    if (!fromPageId || !toPageId || !sessionId) {
      throw new Error('Missing required parameters for edge creation');
    }
    
    try {
      // Try to find an existing edge with the same fromPageId, toPageId, and sessionId
      const existingEdge = await db.edges
        .where('[fromPageId+toPageId+sessionId]')
        .equals([fromPageId, toPageId, sessionId])
        .first();
      
      if (existingEdge) {
        // Update the existing edge
        await db.edges.update(existingEdge.edgeId, {
          count: (existingEdge.count || 0) + 1,
          lastTraversal: timestamp,
          isBackNavigation: isBackNavigation || existingEdge.isBackNavigation
        });
        
        return existingEdge.edgeId;
      }
      
      // Create a new edge
      const edgeId = generateEdgeId();
      
      await db.edges.add({
        edgeId,
        fromPageId,
        toPageId,
        sessionId,
        timestamp,
        count: 1,
        firstTraversal: timestamp,
        lastTraversal: timestamp,
        isBackNavigation
      });
      
      return edgeId;
    } catch (error) {
      console.error('[EdgeRepository] Error creating/updating edge:', error);
      throw error;
    }
  }
  
  /**
   * Get edges starting from a specific page
   * @param fromPageId The source page ID
   * @param limit Maximum number of edges to return
   * @returns Array of edges originating from the page
   */
  async getOutgoingEdges(fromPageId: string, limit = 50): Promise<EdgeRecord[]> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    return db.edges
      .where('fromPageId')
      .equals(fromPageId)
      .limit(limit)
      .toArray();
  }
  
  /**
   * Get edges pointing to a specific page
   * @param toPageId The destination page ID
   * @param limit Maximum number of edges to return
   * @returns Array of edges pointing to the page
   */
  async getIncomingEdges(toPageId: string, limit = 50): Promise<EdgeRecord[]> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    return db.edges
      .where('toPageId')
      .equals(toPageId)
      .limit(limit)
      .toArray();
  }
  
  /**
   * Get the most frequently traversed edges
   * @param limit Maximum number of edges to return
   * @returns Array of edges sorted by count (descending)
   */
  async getTopEdges(limit = 20): Promise<EdgeRecord[]> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    // This needs to load all edges and sort in memory since IndexedDB
    // doesn't support sorting by non-indexed fields
    return db.edges
      .toArray()
      .then(edges => edges
        .sort((a, b) => (b.count || 0) - (a.count || 0))
        .slice(0, limit)
      );
  }
  
  /**
   * Get all edges within a specific session
   * @param sessionId The session ID
   * @returns Array of edges within the session
   */
  async getEdgesBySession(sessionId: number): Promise<EdgeRecord[]> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    return db.edges
      .where('sessionId')
      .equals(sessionId)
      .toArray();
  }
  
  /**
   * Delete edges related to a specific page
   * @param pageId The page ID
   * @returns Number of edges deleted
   */
  async deleteEdgesForPage(pageId: string): Promise<number> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    // Delete incoming edges
    const incomingCount = await db.edges
      .where('toPageId')
      .equals(pageId)
      .delete();
    
    // Delete outgoing edges
    const outgoingCount = await db.edges
      .where('fromPageId')
      .equals(pageId)
      .delete();
    
    return incomingCount + outgoingCount;
  }
  
  /**
   * Check if a direct connection exists between two pages
   * @param fromPageId The source page ID
   * @param toPageId The destination page ID
   * @returns True if a connection exists
   */
  async hasConnection(fromPageId: string, toPageId: string): Promise<boolean> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    const count = await db.edges
      .where('fromPageId')
      .equals(fromPageId)
      .and(edge => edge.toPageId === toPageId)
      .count();
    
    return count > 0;
  }
  
  /**
   * Get all edges in the database
   * @returns Array of all edge records
   */
  async getAllEdges(): Promise<EdgeRecord[]> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    return db.edges.toArray();
  }
}

// Create and export a singleton instance
export const edgeRepository = new EdgeRepository();

// Default export for convenience
export default EdgeRepository;


==========================================
FILE: src/db/repositories/EventRepository.ts
==========================================

/**
 * @file EventRepository.ts
 * 
 * Repository for working with event records in the database.
 * Events represent user actions, system operations, and other notable occurrences.
 */

import { DatabaseManager } from '../DatabaseCore';
import { EventRecord } from '../../types';
import { generateEventId } from '../../utils/idGenerator';

/**
 * Enum of standard event types
 * This can be extended as needed for new event types
 */
export enum EventType {
  // Session events
  SESSION_STARTED = 'session_started',
  SESSION_ENDED = 'session_ended',
  
  // Page events
  PAGE_VISITED = 'page_visited',
  CONTENT_EXTRACTED = 'content_extracted',
  
  // User actions
  SEARCH_PERFORMED = 'search_performed',
  SEARCH_RESULT_CLICKED = 'search_result_clicked',
  
  // System events
  SYNC_STARTED = 'sync_started',
  SYNC_COMPLETED = 'sync_completed',
  SYNC_FAILED = 'sync_failed',
  
  // Auth events
  USER_LOGGED_IN = 'user_logged_in',
  USER_LOGGED_OUT = 'user_logged_out'
}

/**
 * Repository for managing event records in the database
 */
export class EventRepository {
  /**
   * Log an event to the database
   * @param operation The type of event/operation
   * @param sessionId The session ID associated with the event
   * @param data Additional data for the event
   * @param userId Optional user ID
   * @param userEmail Optional user email
   * @returns The event ID
   */
  async logEvent(
    operation: string,
    sessionId: string,
    data: any = {},
    userId?: string,
    userEmail?: string
  ): Promise<number> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    if (!operation || !sessionId) {
      throw new Error('Operation and session ID are required for logging events');
    }
    
    const now = Date.now();
    const eventId = generateEventId();
    
    try {
      // Create the event record
      await db.events.add({
        eventId,
        operation,
        sessionId,
        userId,
        userEmail,
        timestamp: now,
        data,
        loggedAt: now
      });
      
      // For certain events, we might want to perform additional actions
      // For example, sync to backend for important events
      if (this.shouldTriggerBackendSync(operation)) {
        // Queue for background sync (placeholder - would be implemented elsewhere)
        console.log(`[EventRepository] Event ${eventId} (${operation}) queued for sync`);
      }
      
      return eventId;
    } catch (error) {
      console.error(`[EventRepository] Error logging event (${operation}):`, error);
      throw error;
    }
  }
  
  /**
   * Helper method to determine if an event should trigger backend sync
   * This can be customized based on which events need immediate syncing
   */
  private shouldTriggerBackendSync(operation: string): boolean {
    const highPriorityEvents = [
      EventType.USER_LOGGED_IN,
      EventType.USER_LOGGED_OUT,
      EventType.SEARCH_PERFORMED,
      EventType.SEARCH_RESULT_CLICKED
    ];
    
    return highPriorityEvents.includes(operation as EventType);
  }
  
  /**
   * Get events by session ID
   * @param sessionId The session ID
   * @param limit Maximum number of events to return
   * @returns Array of events for the session
   */
  async getEventsBySession(sessionId: string, limit = 100): Promise<EventRecord[]> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    return db.events
      .where('sessionId')
      .equals(sessionId)
      .limit(limit)
      .toArray();
  }
  
  /**
   * Get events by type/operation
   * @param operation The event type/operation
   * @param limit Maximum number of events to return
   * @returns Array of events of the specified type
   */
  async getEventsByType(operation: string, limit = 100): Promise<EventRecord[]> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    return db.events
      .where('operation')
      .equals(operation)
      .limit(limit)
      .toArray();
  }
  
  /**
   * Get recent events, optionally filtered by operation
   * @param limit Maximum number of events to return
   * @param operation Optional operation type to filter by
   * @returns Array of recent events
   */
  async getRecentEvents(limit = 100, operation?: string): Promise<EventRecord[]> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    // Build query based on whether we're filtering by operation
    let collection = db.events.orderBy('timestamp').reverse();
    
    if (operation) {
      collection = collection.filter(event => event.operation === operation);
    }
    
    return collection.limit(limit).toArray();
  }
  
  /**
   * Get counts of events by operation type
   * @returns Object with counts keyed by operation type
   */
  async getEventCounts(): Promise<Record<string, number>> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    const events = await db.events.toArray();
    
    // Use reduce to count events by operation
    return events.reduce((counts: Record<string, number>, event) => {
      const op = event.operation;
      counts[op] = (counts[op] || 0) + 1;
      return counts;
    }, {});
  }
  
  /**
   * Clear all events from the database
   * Use with caution - primarily for testing/development
   */
  async clearAllEvents(): Promise<void> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    await db.events.clear();
    console.log('[EventRepository] All events have been cleared');
  }
  
  /**
   * Get events that have not been synced to the backend
   * This could be used by a cold storage sync service
   * @param limit Maximum number of events to return
   * @returns Array of unsynced events
   */
  async getUnsyncedEvents(limit = 500): Promise<EventRecord[]> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    // This assumes events would have a 'synced' flag in their data
    // You might need to adjust based on your actual sync tracking mechanism
    return db.events
      .filter(event => !event.data?.synced)
      .limit(limit)
      .toArray();
  }
  
  /**
   * Mark events as synced
   * @param eventIds Array of event IDs that have been synced
   */
  async markEventsSynced(eventIds: number[]): Promise<void> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    // For each event ID, update the synced status
    for (const eventId of eventIds) {
      try {
        const event = await db.events.get(eventId);
        if (event) {
          // Update the data field to include synced: true
          const updatedData = { ...event.data, synced: true };
          await db.events.update(eventId, { data: updatedData });
        }
      } catch (error) {
        console.error(`[EventRepository] Error marking event ${eventId} as synced:`, error);
        // Continue with other events even if one fails
      }
    }
  }
  
  /**
   * Get the total count of event records
   * @returns Count of event records
   */
  async getCount(): Promise<number> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    return db.events.count();
  }
  
  /**
   * Get events of a specific type that occurred after a timestamp
   * @param eventType The type of events to retrieve
   * @param timestamp The timestamp to filter events after
   * @returns Array of matching event records
   */
  async getEventsByTypeAfterTime(eventType: EventType, timestamp: number): Promise<EventRecord[]> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    return db.events
      .where('operation')
      .equals(eventType)
      .and(e => e.timestamp > timestamp)
      .toArray();
  }
}

// Create and export a singleton instance
export const eventRepository = new EventRepository();

// Default export for convenience
export default EventRepository;


==========================================
FILE: src/db/repositories/MetadataRepository.ts
==========================================

/**
 * @file MetadataRepository.ts
 * 
 * Repository for working with application metadata in the database.
 * Provides methods to save and retrieve key-value pairs.
 */

import { DatabaseManager } from '../DatabaseCore';
import { MetadataRecord } from '../../types';

/**
 * Repository for managing metadata records in the database
 */
export class MetadataRepository {
  /**
   * Get a metadata record by its key
   * @param key The metadata key to look up
   * @returns The metadata record if found, undefined otherwise
   */
  async getByKey(key: string): Promise<MetadataRecord | undefined> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    return db.metadata.get(key);
  }
  
  /**
   * Save a value with the specified key
   * @param key The metadata key
   * @param value The value to store
   * @returns The updated metadata record
   */
  async saveValue(key: string, value: string): Promise<void> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    await db.metadata.put({
      key,
      value,
      updatedAt: Date.now()
    });
  }
  
  /**
   * Get all metadata records
   * @returns Array of all metadata records
   */
  async getAllMetadata(): Promise<MetadataRecord[]> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    return db.metadata.toArray();
  }
  
  /**
   * Delete a metadata record by key
   * @param key The key to delete
   * @returns True if deleted, false if not found
   */
  async deleteByKey(key: string): Promise<boolean> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    try {
      await db.metadata.delete(key);
      return true;
    } catch (error) {
      console.error(`[MetadataRepository] Error deleting metadata ${key}:`, error);
      return false;
    }
  }
}

// Create and export a singleton instance
export const metadataRepository = new MetadataRepository();

// Default export for convenience
export default MetadataRepository;


==========================================
FILE: src/db/repositories/PageRepository.ts
==========================================

/**
 * @file PageRepository.ts
 * 
 * Repository for working with page records in the database.
 * Provides methods to create, retrieve, update, and query web pages.
 */

import { DatabaseManager } from '../DatabaseCore';
import { PageRecord } from '../../types';
import { generatePageId } from '../../utils/idGenerator';

/**
 * Repository for managing page records in the database.
 */
export class PageRepository {
  /**
   * Get a page record by its URL
   * @param url The URL to look up
   * @returns The page record if found, undefined otherwise
   */
  async getByUrl(url: string): Promise<PageRecord | undefined> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    return db.pages.where('url').equals(url).first();
  }
  
  /**
   * Get a page record by its ID
   * @param pageId The page ID to look up
   * @returns The page record if found, undefined otherwise
   */
  async getById(pageId: string): Promise<PageRecord | undefined> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    return db.pages.get(pageId);
  }
  
  /**
   * Create or update a page record by URL
   * If the page exists, updates its visit count and last visit time
   * If the page doesn't exist, creates a new page record
   * 
   * @param url The URL of the page
   * @param title Optional title for the page
   * @param timestamp Optional timestamp for the visit (defaults to now)
   * @returns The page ID
   */
  async createOrUpdate(url: string, title?: string, timestamp?: number): Promise<string> {
    if (!url) {
      console.error('[PageRepository] Cannot create page record without URL');
      throw new Error('URL is required');
    }
    
    const now = timestamp || Date.now();
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    try {
      // Check if we already have a page with this URL
      const existingPage = await this.getByUrl(url);
      
      if (existingPage) {
        // Update the existing page with new visit information
        await db.pages.update(existingPage.pageId, {
          lastVisit: now,
          visitCount: (existingPage.visitCount || 0) + 1,
          title: title || existingPage.title,
          updatedAt: now
        });
        
        return existingPage.pageId;
      }
      
      // Create a new page record
      const pageId = generatePageId(url);
      
      await db.pages.add({
        pageId,
        url,
        title: title || url,
        firstVisit: now,
        lastVisit: now,
        updatedAt: now,
        visitCount: 1,
        totalActiveTime: 0,
        domain: new URL(url).hostname,
        personalScore: 0.5,
        syncStatus: 'pending'
      });
      
      return pageId;
    } catch (error) {
      console.error('[PageRepository] Error creating/getting page:', error);
      throw error;
    }
  }
  
  /**
   * Update the active time for a page
   * @param pageId The ID of the page
   * @param duration The duration to add in seconds
   */
  async updateActiveTime(pageId: string, duration: number): Promise<void> {
    if (duration <= 0) return;
    
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    const page = await this.getById(pageId);
    if (!page) {
      console.warn(`[PageRepository] Cannot update active time for unknown page: ${pageId}`);
      return;
    }
    
    await db.pages.update(pageId, {
      totalActiveTime: (page.totalActiveTime || 0) + duration,
      updatedAt: Date.now()
    });
  }
  
  /**
   * Get recently visited pages
   * @param limit Maximum number of pages to return
   * @returns Array of page records sorted by last visit time (descending)
   */
  async getRecentPages(limit = 10): Promise<PageRecord[]> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    return db.pages
      .orderBy('lastVisit')
      .reverse()
      .limit(limit)
      .toArray();
  }
  
  /**
   * Find pages with a title or URL containing the search text
   * @param searchText The text to search for
   * @param limit Maximum number of results to return
   * @returns Array of matching page records
   */
  async search(searchText: string, limit = 20): Promise<PageRecord[]> {
    if (!searchText || searchText.trim().length < 2) {
      return [];
    }
    
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    // Convert search text to lowercase for case-insensitive search
    const query = searchText.toLowerCase();
    
    // We have to do filtering in memory since IndexedDB 
    // doesn't support advanced text search
    return db.pages
      .filter(page => {
        const titleMatch = page.title?.toLowerCase().includes(query);
        const urlMatch = page.url?.toLowerCase().includes(query);
        return titleMatch || urlMatch;
      })
      .limit(limit)
      .toArray();
  }
  
  /**
   * Delete a page by ID
   * @param pageId The ID of the page to delete
   * @returns True if the page was deleted, false if it didn't exist
   */
  async deletePage(pageId: string): Promise<boolean> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    try {
      await db.pages.delete(pageId);
      return true;
    } catch (error) {
      console.error(`[PageRepository] Error deleting page ${pageId}:`, error);
      return false;
    }
  }
  
  /**
   * Get all pages in the database
   * @returns Array of all page records
   */
  async getAllPages(): Promise<PageRecord[]> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    return db.pages.toArray();
  }
  
  /**
   * Update a page's personal score
   * @param pageId The ID of the page
   * @param score The new personal score value
   */
  async updatePersonalScore(pageId: string, score: number): Promise<void> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    await db.pages.update(pageId, {
      personalScore: score,
      updatedAt: Date.now()
    });
  }
  
  /**
   * Get the total count of page records
   * @returns Count of page records
   */
  async getCount(): Promise<number> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    return db.pages.count();
  }
  
  /**
   * Get pages that were updated after a specific time
   * @param timestamp Only include pages updated after this time
   * @returns Array of page records
   */
  async getPagesUpdatedAfterTime(timestamp: number): Promise<PageRecord[]> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    return db.pages
      .where('updatedAt')
      .above(timestamp)
      .toArray();
  }
}

// Create and export a singleton instance
export const pageRepository = new PageRepository();

// Default export for convenience
export default PageRepository;


==========================================
FILE: src/db/repositories/PreferencesRepository.ts
==========================================

/**
 * @file PreferencesRepository.ts
 * 
 * Repository for accessing and storing user preferences in Chrome storage
 */

import { STORAGE_KEYS } from '../../config';

// Type definition for user preferences
export interface UserPreferences {
  theme: 'light' | 'dark' | 'system';
  // Add other preferences as needed
}

// Default preferences when none are set
const DEFAULT_PREFERENCES: UserPreferences = {
  theme: 'system'
};

/**
 * Repository for managing user preferences in storage
 */
export class PreferencesRepository {
  /**
   * Get all user preferences
   * @returns Promise resolving to user preferences
   */
  async getPreferences(): Promise<UserPreferences> {
    return new Promise((resolve) => {
      chrome.storage.sync.get(STORAGE_KEYS.PREFERRED_THEME_KEY, (result) => {
        // If no preferences found, return defaults
        if (!result || !result[STORAGE_KEYS.PREFERRED_THEME_KEY]) {
          resolve(DEFAULT_PREFERENCES);
          return;
        }
        
        try {
          // Parse stored preferences
          const storedPrefs = result[STORAGE_KEYS.PREFERRED_THEME_KEY];
          resolve({
            ...DEFAULT_PREFERENCES,
            ...(typeof storedPrefs === 'string' ? { theme: storedPrefs } : storedPrefs)
          });
        } catch (e) {
          console.error('[PreferencesRepository] Error parsing preferences:', e);
          resolve(DEFAULT_PREFERENCES);
        }
      });
    });
  }

  /**
   * Get the current theme preference
   * @returns Promise resolving to the theme
   */
  async getTheme(): Promise<UserPreferences['theme']> {
    const prefs = await this.getPreferences();
    return prefs.theme;
  }

  /**
   * Save user preferences
   * @param preferences The preferences to save
   * @returns Promise resolving when saved
   */
  async savePreferences(preferences: UserPreferences): Promise<void> {
    return new Promise((resolve) => {
      chrome.storage.sync.set(
        { [STORAGE_KEYS.PREFERRED_THEME_KEY]: preferences }, 
        () => resolve()
      );
    });
  }

  /**
   * Update the theme preference
   * @param theme The theme to set
   * @returns Promise resolving when saved
   */
  async saveTheme(theme: UserPreferences['theme']): Promise<void> {
    const prefs = await this.getPreferences();
    return this.savePreferences({ ...prefs, theme });
  }
}

export default new PreferencesRepository();


==========================================
FILE: src/db/repositories/SessionRepository.ts
==========================================

/**
 * @file SessionRepository.ts
 * 
 * Repository for working with browsing sessions in the database.
 * Handles creating, ending, and managing browser sessions.
 */

import { DatabaseManager } from '../DatabaseCore';
import { BrowsingSession } from '../../types';
import { generateSessionId } from '../../utils/idGenerator';

/**
 * Repository for managing browsing sessions
 */
export class SessionRepository {
  // Track the current session ID
  private currentSessionId: number | null = null;
  
  // Storage key for persisting session state
  private readonly SESSION_STORAGE_KEY = 'doryCurrentSession';
  
  /**
   * Get the current active session ID
   * @returns The current session ID or null if no active session
   */
  getCurrentSessionId(): number | null {
    return this.currentSessionId;
  }
  
  /**
   * Start a new browsing session
   * @param idleThreshold Optional timeout in ms for session reuse
   * @returns The ID of the new or resumed session
   */
  async startNewSession(idleThreshold = 30 * 60 * 1000): Promise<number> {
    // Try to reuse a recent session if available
    const recentSession = await this.getRecentSession(idleThreshold);
    if (recentSession) {
      this.currentSessionId = recentSession;
      await this.updateSessionActivityTime(recentSession);
      return recentSession;
    }
    
    // End any existing session
    if (this.currentSessionId) {
      await this.endSession(this.currentSessionId);
    }
    
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    const now = Date.now();
    
    // Create new session ID
    const sessionId = generateSessionId();
    
    // Add new session to database
    await db.sessions.add({
      sessionId,
      startTime: now,
      lastActivityAt: now,
      totalActiveTime: 0,
      isActive: true
    });
    
    // Update current session ID
    this.currentSessionId = sessionId;
    
    // Persist session state
    await this.persistSessionState(sessionId, now);
    
    return sessionId;
  }
  
  /**
   * End a browsing session
   * @param sessionId The ID of the session to end, defaults to current session
   */
  async endSession(sessionId?: number): Promise<void> {
    const targetId = sessionId || this.currentSessionId;
    if (!targetId) return; // No session to end
    
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    const now = Date.now();
    
    try {
      // Get the session
      const session = await db.sessions.get(targetId);
      if (!session) {
        console.warn(`[SessionRepository] Session ${targetId} not found to end`);
        return;
      }
      
      // Calculate total session time
      const totalActiveTime = Math.max(
        (session.totalActiveTime || 0),
        Math.ceil((now - session.startTime) / 1000)
      );
      
      // Update session as ended
      await db.sessions.update(targetId, {
        endTime: now,
        lastActivityAt: now,
        totalActiveTime,
        isActive: false
      });
      
      // Clear current session if this is the active one
      if (this.currentSessionId === targetId) {
        this.currentSessionId = null;
        await chrome.storage.local.remove(this.SESSION_STORAGE_KEY);
      }
    } catch (error) {
      console.error(`[SessionRepository] Error ending session ${targetId}:`, error);
      throw error;
    }
  }
  
  /**
   * Update a session's last activity time
   * @param sessionId The session ID to update, defaults to current session
   * @returns True if session was updated, false otherwise
   */
  async updateSessionActivityTime(sessionId?: number): Promise<boolean> {
    const targetId = sessionId || this.currentSessionId;
    if (!targetId) return false; // No session to update
    
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    const now = Date.now();
    
    try {
      // Update session activity time
      await db.sessions.update(targetId, {
        lastActivityAt: now
      });
      
      // Persist state to storage
      await this.persistSessionState(targetId, now);
      
      return true;
    } catch (error) {
      console.error(`[SessionRepository] Error updating session ${targetId}:`, error);
      return false;
    }
  }
  
  /**
   * Check if the current session is idle beyond the threshold
   * If idle, automatically end the session
   * @param thresholdMs Idle time threshold in milliseconds
   * @returns True if the session was ended due to idleness
   */
  async checkSessionIdle(thresholdMs = 30 * 60 * 1000): Promise<boolean> {
    if (!this.currentSessionId) return false;
    
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    try {
      const session = await db.sessions.get(this.currentSessionId);
      if (!session || !session.isActive) return false;
      
      const now = Date.now();
      const timeSinceActivity = now - session.lastActivityAt;
      
      if (timeSinceActivity > thresholdMs) {
        // Session has been idle too long, end it
        await this.endSession(this.currentSessionId);
        return true;
      }
      
      return false;
    } catch (error) {
      console.error(`[SessionRepository] Error checking session idle:`, error);
      return false;
    }
  }
  
  /**
   * Get a session by ID
   * @param sessionId The session ID
   * @returns The session or undefined if not found
   */
  async getSession(sessionId: number): Promise<BrowsingSession | undefined> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    return db.sessions.get(sessionId);
  }
  
  /**
   * Get all active sessions
   * @returns Array of active session records
   */
  async getActiveSessions(): Promise<BrowsingSession[]> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    return db.sessions
      .filter(session => session.isActive === true)
      .toArray();
  }
  
  /**
   * Get all sessions in the database
   * @returns Array of all session records
   */
  async getAllSessions(): Promise<BrowsingSession[]> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    return db.sessions.toArray();
  }
  
  /**
   * Get the total count of session records
   * @returns Count of session records
   */
  async getCount(): Promise<number> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    return db.sessions.count();
  }
  
  /**
   * Get sessions that started after a specific time
   * @param timestamp Only include sessions that started after this time
   * @returns Array of session records
   */
  async getSessionsAfterTime(timestamp: number): Promise<BrowsingSession[]> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    return db.sessions
      .where('startTime')
      .above(timestamp)
      .toArray();
  }
  
  /**
   * Stores the current session state in chrome.storage.local for persistence
   * @param sessionId The session ID to store
   * @param lastActivity The timestamp of the last activity
   */
  private async persistSessionState(sessionId: number, lastActivity: number): Promise<void> {
    try {
      await chrome.storage.local.set({
        [this.SESSION_STORAGE_KEY]: {
          sessionId,
          lastActivityAt: lastActivity
        }
      });
    } catch (error) {
      console.error('[SessionRepository] Error persisting session state:', error);
    }
  }
  
  /**
   * Check if there's a recent active session we can reuse
   * @param idleThreshold The threshold in ms to consider a session still active
   * @returns The session ID if a recent session exists, null otherwise
   */
  private async getRecentSession(idleThreshold: number): Promise<number | null> {
    try {
      // Check for saved session in storage
      const storage = await chrome.storage.local.get(this.SESSION_STORAGE_KEY);
      const savedSession = storage[this.SESSION_STORAGE_KEY];
      
      if (savedSession && savedSession.sessionId && savedSession.lastActivityAt) {
        const now = Date.now();
        
        // If the last activity was within the idle threshold, session is still valid
        if (now - savedSession.lastActivityAt < idleThreshold) {
          // Check if this session is still marked as active in the database
          const db = DatabaseManager.getCurrentDatabase();
          if (!db) throw new Error('No active database');
          
          const session = await db.sessions.get(savedSession.sessionId);
          if (session && session.isActive) {
            return savedSession.sessionId;
          }
        }
      }
      
      return null;
    } catch (error) {
      console.error('[SessionRepository] Error getting recent session:', error);
      return null;
    }
  }
}

// Create and export a singleton instance
export const sessionRepository = new SessionRepository();

// Default export for convenience
export default SessionRepository;


==========================================
FILE: src/db/repositories/VisitRepository.ts
==========================================

/**
 * @file VisitRepository.ts
 * 
 * Repository for working with page visit records in the database.
 * Visits represent specific instances of viewing a page within a session.
 */

import { DatabaseManager } from '../DatabaseCore';
import { VisitRecord } from '../../types';
import { generateVisitId } from '../../utils/idGenerator';

/**
 * Repository for managing page visit records
 */
export class VisitRepository {
  /**
   * Start a new visit to a page
   * @param pageId The ID of the page being visited
   * @param sessionId The ID of the current browsing session
   * @param fromPageId Optional ID of the page navigated from
   * @param isBackNavigation Whether this is a back/forward navigation
   * @returns The new visit ID
   */
  async startVisit(
    pageId: string,
    sessionId: number,
    fromPageId?: string,
    isBackNavigation: boolean = false
  ): Promise<string> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    if (!pageId || !sessionId) {
      throw new Error('Page ID and session ID are required to start a visit');
    }
    
    const now = Date.now();
    const visitId = generateVisitId();
    
    try {
      // Create a new visit record
      await db.visits.add({
        visitId,
        pageId,
        sessionId,
        fromPageId,
        startTime: now,
        totalActiveTime: 0,
        isBackNavigation
      });
      
      return visitId;
    } catch (error) {
      console.error('[VisitRepository] Error starting visit:', error);
      throw error;
    }
  }
  
  /**
   * End a visit by setting its end time
   * @param visitId The ID of the visit to end
   * @param endTime Optional timestamp when the visit ended (defaults to now)
   */
  async endVisit(visitId: string, endTime: number = Date.now()): Promise<void> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    if (!visitId) {
      console.warn('[VisitRepository] Cannot end visit: no visit ID provided');
      return;
    }
    
    try {
      const visit = await db.visits.get(visitId);
      if (!visit) {
        console.warn(`[VisitRepository] Cannot end visit: visit ${visitId} not found`);
        return;
      }
      
      // If already ended, just update if the new end time is later
      if (visit.endTime && visit.endTime > endTime) {
        return;
      }
      
      // Calculate total active time if not already set
      let totalActiveTime = visit.totalActiveTime || 0;
      if (!visit.endTime && visit.startTime) {
        // Add time from start to end if not already tracked
        const additionalTime = Math.max(0, Math.floor((endTime - visit.startTime) / 1000));
        totalActiveTime += additionalTime;
      }
      
      // Update the visit record
      await db.visits.update(visitId, {
        endTime,
        totalActiveTime
      });
    } catch (error) {
      console.error(`[VisitRepository] Error ending visit ${visitId}:`, error);
      throw error;
    }
  }
  
  /**
   * Update the active time for a visit
   * @param visitId The ID of the visit
   * @param duration The duration to add in seconds
   */
  async updateActiveTime(visitId: string, duration: number): Promise<void> {
    if (duration <= 0) return;
    
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    if (!visitId) {
      console.warn('[VisitRepository] Cannot update active time: no visit ID provided');
      return;
    }
    
    try {
      const visit = await db.visits.get(visitId);
      if (!visit) {
        console.warn(`[VisitRepository] Cannot update active time: visit ${visitId} not found`);
        return;
      }
      
      await db.visits.update(visitId, {
        totalActiveTime: (visit.totalActiveTime || 0) + duration
      });
    } catch (error) {
      console.error(`[VisitRepository] Error updating active time for visit ${visitId}:`, error);
      throw error;
    }
  }
  
  /**
   * Get a visit by its ID
   * @param visitId The visit ID
   * @returns The visit record or undefined if not found
   */
  async getVisit(visitId: string): Promise<VisitRecord | undefined> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    return db.visits.get(visitId);
  }
  
  /**
   * Get all visits for a specific page
   * @param pageId The page ID
   * @param limit Maximum number of visits to return
   * @returns Array of visit records for the page
   */
  async getVisitsForPage(pageId: string, limit = 50): Promise<VisitRecord[]> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    return db.visits
      .where('pageId')
      .equals(pageId)
      .reverse() // Most recent first
      .limit(limit)
      .toArray();
  }
  
  /**
   * Get all visits within a specific session
   * @param sessionId The session ID
   * @returns Array of visit records in the session
   */
  async getVisitsForSession(sessionId: number): Promise<VisitRecord[]> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    return db.visits
      .where('sessionId')
      .equals(sessionId)
      .toArray();
  }
  
  /**
   * Get the most recent visits across all pages
   * @param limit Maximum number of visits to return
   * @returns Array of recent visit records
   */
  async getRecentVisits(limit = 20): Promise<VisitRecord[]> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    // This requires loading all visits and sorting in memory
    // since IndexedDB doesn't support sorting by non-indexed fields
    // Consider adding an index if this becomes a performance issue
    return db.visits
      .toArray()
      .then(visits => visits
        .sort((a, b) => (b.startTime || 0) - (a.startTime || 0))
        .slice(0, limit)
      );
  }
  
  /**
   * Delete visits associated with a page
   * @param pageId The page ID
   * @returns Number of visits deleted
   */
  async deleteVisitsForPage(pageId: string): Promise<number> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    return db.visits
      .where('pageId')
      .equals(pageId)
      .delete();
  }
  
  /**
   * Delete visits associated with a session
   * @param sessionId The session ID
   * @returns Number of visits deleted
   */
  async deleteVisitsForSession(sessionId: number): Promise<number> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    return db.visits
      .where('sessionId')
      .equals(sessionId)
      .delete();
  }
  
  /**
   * Get all visits in the database
   * @returns Array of all visit records
   */
  async getAllVisits(): Promise<VisitRecord[]> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    return db.visits.toArray();
  }
  
  /**
   * Get the total count of visit records
   * @returns Count of visit records
   */
  async getCount(): Promise<number> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    return db.visits.count();
  }
  
  /**
   * Get visits that occurred after a specific time
   * @param timestamp Only include visits after this time
   * @returns Array of visit records
   */
  async getVisitsAfterTime(timestamp: number): Promise<VisitRecord[]> {
    const db = DatabaseManager.getCurrentDatabase();
    if (!db) throw new Error('No active database');
    
    return db.visits
      .where('startTime')
      .above(timestamp)
      .toArray();
  }
}

// Create and export a singleton instance
export const visitRepository = new VisitRepository();

// Default export for convenience
export default VisitRepository;


==========================================
FILE: src/db/repositories/index.ts
==========================================

/**
 * @file index.ts
 * 
 * Barrel file for database repositories.
 * Exports all repository classes and instances.
 */

// Export everything from PageRepository
export * from './PageRepository';

// Export everything from SessionRepository
export * from './SessionRepository';

// Export everything from EdgeRepository
export * from './EdgeRepository';

// Export everything from VisitRepository
export * from './VisitRepository';

// Export everything from EventRepository
export * from './EventRepository';

// Export everything from MetadataRepository
export * from './MetadataRepository';


==========================================
FILE: src/hooks/useBackgroundAuth.ts
==========================================

import { useEffect, useState, useRef, useCallback } from 'react';
import { getBackgroundAPI } from '../utils/comlinkSetup';
import type { BackgroundAPI } from '../background/api';
import type { AuthState } from '../types';

export function useAuth() {
  const [state, setState] = useState<AuthState>({
    isAuthenticated: false,
    user: null,
    accessToken: null,
    refreshToken: null,
  });

  const [loading, setLoading] = useState(true);
  const authRef = useRef<BackgroundAPI['auth'] | null>(null);
  const mountedRef = useRef(true);

  // Initialize auth service once
  useEffect(() => {
    mountedRef.current = true;

    (async () => {
      try {
        const api = await getBackgroundAPI<BackgroundAPI>();
        const auth = api.auth;
        authRef.current = auth;

        const initialState = await auth.getAuthState();
        if (mountedRef.current) {
          setState(initialState);
        }
      } catch (error) {
        console.error('[useAuth] Failed to initialize:', error);
      } finally {
        if (mountedRef.current) {
          setLoading(false);
        }
      }
    })();

    return () => {
      mountedRef.current = false;
    };
  }, []);

  const login = useCallback(async () => {
    try {
      const auth = authRef.current;
      if (!auth) throw new Error('Auth service not ready');

      await auth.login();
      const newState = await auth.getAuthState();
      setState(newState);
      return true;
    } catch (error) {
      console.error('[useAuth] Login failed:', error);
      return false;
    }
  }, []);

  const logout = useCallback(async () => {
    try {
      const auth = authRef.current;
      if (!auth) throw new Error('Auth service not ready');

      await auth.logout();
      const newState = await auth.getAuthState();
      setState(newState);
      return true;
    } catch (error) {
      console.error('[useAuth] Logout failed:', error);
      return false;
    }
  }, []);

  return {
    ...state,
    loading,
    login,
    logout,
  };
}

==========================================
FILE: src/hooks/useBackgroundClustering.ts
==========================================

/**
 * @file useBackgroundClustering.ts
 * 
 * Hook for accessing clustering functionality through the background API.
 * Provides methods to get cluster suggestions and trigger clustering.
 */

import { useState, useCallback, useRef, useEffect } from 'react';
import { getBackgroundAPI } from '../utils/comlinkSetup';
import type { BackgroundAPI } from '../background/api';
import type { ClusterSuggestion } from '../types';

interface ClusteringResult {
  current: ClusterSuggestion[];
  previous: ClusterSuggestion[];
}

interface UseClusteringResult {
  clusters: ClusterSuggestion[];
  previousClusters: ClusterSuggestion[];
  loading: boolean;
  error: Error | null;
  getClusters: (options?: { forceRefresh?: boolean; count?: number }) => Promise<ClusteringResult>;
  triggerClustering: () => Promise<void>;
}

const useBackgroundClustering = (): UseClusteringResult => {
  const [clusters, setClusters] = useState<ClusterSuggestion[]>([]);
  const [previousClusters, setPreviousClusters] = useState<ClusterSuggestion[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const clusteringServiceRef = useRef<BackgroundAPI['clusters'] | null>(null);
  const loadingRef = useRef(false);

  // Initialize the Comlink proxy once
  useEffect(() => {
    let mounted = true;

    (async () => {
      try {
        const api = await getBackgroundAPI<BackgroundAPI>();
        const service = api.clusters;
        if (mounted) {
          clusteringServiceRef.current = service;
        }
      } catch (err) {
        console.error('[useBackgroundClustering] Failed to initialize:', err);
        setError(err instanceof Error ? err : new Error('Initialization error'));
      }
    })();

    return () => {
      mounted = false;
    };
  }, []);

  const getClusters = useCallback(async (options?: { forceRefresh?: boolean; count?: number }) => {
    const service = clusteringServiceRef.current;
    if (!service) throw new Error('Clustering service not initialized');

    if (loadingRef.current) {
      console.warn('[useBackgroundClustering] Cluster fetch already in progress.');
      return { current: [], previous: [] };
    }

    try {
      loadingRef.current = true;
      setLoading(true);
      setError(null);

      const result = await service.getClusterSuggestions(options);
      setClusters(result.current);
      setPreviousClusters(result.previous);

      return result;
    } catch (err) {
      console.error('[useBackgroundClustering] Error fetching clusters:', err);
      const error = err instanceof Error ? err : new Error('Unknown error during clustering');
      setError(error);
      return { current: [], previous: [] };
    } finally {
      loadingRef.current = false;
      setLoading(false);
    }
  }, []);

  const triggerClustering = useCallback(async () => {
    const service = clusteringServiceRef.current;
    if (!service) throw new Error('Clustering service not initialized');

    try {
      await service.triggerClustering();
    } catch (err) {
      console.error('[useBackgroundClustering] Error triggering clustering:', err);
      throw err;
    }
  }, []);

  return {
    clusters,
    previousClusters,
    loading,
    error,
    getClusters,
    triggerClustering,
  };
};

export default useBackgroundClustering;

==========================================
FILE: src/hooks/useBackgroundPreferences.ts
==========================================

/**
 * @file useBackgroundPreferences.ts
 * 
 * React hook for accessing preference-related functionality from the background
 */

import { useState, useEffect, useCallback, useRef } from 'react';
import { getBackgroundAPI } from '../utils/comlinkSetup';
import type { BackgroundAPI } from '../background/api';
import type { UserPreferences } from '../db/repositories/PreferencesRepository';

interface UsePreferencesResult {
  theme: UserPreferences['theme'];
  isDarkMode: boolean;
  loading: boolean;
  toggleTheme: () => Promise<UserPreferences['theme']>;
  setTheme: (theme: UserPreferences['theme']) => Promise<boolean>;
}

export function useBackgroundPreferences(): UsePreferencesResult {
  const [theme, setTheme] = useState<UserPreferences['theme']>('system');
  const [loading, setLoading] = useState(true);
  const preferencesRef = useRef<BackgroundAPI['preferences'] | null>(null);

  // Initialize once
  useEffect(() => {
    let mounted = true;

    (async () => {
      try {
        setLoading(true);
        const api = await getBackgroundAPI<BackgroundAPI>();
        preferencesRef.current = api.preferences;

        const currentTheme = await api.preferences.getTheme();
        if (mounted) setTheme(currentTheme);
      } catch (err) {
        console.error('[useBackgroundPreferences] Failed to initialize:', err);
      } finally {
        if (mounted) setLoading(false);
      }
    })();

    return () => {
      mounted = false;
    };
  }, []);

  const toggleTheme = useCallback(async (): Promise<UserPreferences['theme']> => {
    const service = preferencesRef.current;
    if (!service) {
      console.warn('[useBackgroundPreferences] Preferences service not ready');
      return theme;
    }

    try {
      const newTheme = await service.toggleTheme();
      setTheme(newTheme);
      return newTheme;
    } catch (error) {
      console.error('[useBackgroundPreferences] Failed to toggle theme:', error);
      return theme;
    }
  }, [theme]);

  const setThemePreference = useCallback(async (newTheme: UserPreferences['theme']): Promise<boolean> => {
    const service = preferencesRef.current;
    if (!service) {
      console.warn('[useBackgroundPreferences] Preferences service not ready');
      return false;
    }

    try {
      await service.setTheme(newTheme);
      setTheme(newTheme);
      return true;
    } catch (error) {
      console.error('[useBackgroundPreferences] Failed to set theme:', error);
      return false;
    }
  }, []);

  const effectiveTheme = theme === 'system'
    ? (window.matchMedia?.('(prefers-color-scheme: dark)').matches ? 'dark' : 'light')
    : theme;

  const isDarkMode = effectiveTheme === 'dark';

  // Update DOM class
  useEffect(() => {
    document.body.classList.toggle('dark-mode', isDarkMode);
  }, [isDarkMode]);

  return {
    theme,
    isDarkMode,
    loading,
    toggleTheme,
    setTheme: setThemePreference,
  };
}

export default useBackgroundPreferences;

==========================================
FILE: src/hooks/useBackgroundSearch.ts
==========================================

/**
 * @file useBackgroundSearch.ts
 * 
 * React hook for searching via the background API
 * Provides a unified interface for local, semantic, and hybrid search
 */

import { useState, useCallback } from 'react';
import { getBackgroundAPI } from '../utils/comlinkSetup';
import type { BackgroundAPI } from '../background/api';
import { SearchResult } from '../types';
import { SearchOptions } from '../services/searchService';

/**
 * Hook for accessing search functionality from the background API
 * @returns Search methods and event tracking
 */
export function useBackgroundSearch() {
  // Generate a unique search session ID for tracking
  const [searchSessionId] = useState<string>(`search_${Date.now()}_${Math.random().toString(36).substring(2, 7)}`);

  
  /**
   * Perform a local search using the background API
   * @param query The search query
   * @returns Promise resolving to search results
   */
  const searchLocal = useCallback(async (query: string): Promise<SearchResult[]> => {
    if (!query || query.trim().length === 0) {
      return [];
    }
    
    try {
      const api = await getBackgroundAPI<BackgroundAPI>();
      
      // Get search results (this should work regardless of DB state since it can fallback to chrome history)
      const searchService = api.search;
      const results = await searchService.searchLocal(query);
      
      // Track search events (these will wait for database if needed)
      try {
        const eventService = api.events;
        await eventService.trackSearchPerformed(query, results.length, 'local');
      } catch (trackError) {
        // Just log the error but don't fail the search
        console.warn('[useBackgroundSearch] Failed to track search:', trackError);
      }
      
      return results;
    } catch (error) {
      console.error('[useBackgroundSearch] Local search error:', error);
      return [];
    }
  }, []);
  
  
  /**
   * Perform a semantic search using the background API
   * @param query The search query
   * @param options Optional search options
   * @returns Promise resolving to search results
   */
  const searchSemantic = useCallback(async (query: string, options?: SearchOptions): Promise<SearchResult[]> => {
    if (!query || query.trim().length === 0) {
      return [];
    }
    
    try {
      const api = await getBackgroundAPI<BackgroundAPI>();
      const searchService = api.search; // Removed await - search is a direct object, not a Promise
      const results = await searchService.searchSemantic(query, options);
      
      // Track this semantic search
      const eventService = api.events; // Removed await - events is a direct object, not a Promise
      await eventService.trackSearchPerformed(
        query, 
        results.length, 
        'semantic'
      );
      
      return results;
    } catch (error) {
      console.error('[useBackgroundSearch] Semantic search error:', error);
      return [];
    }
  }, []);
  
  /**
   * Perform a hybrid search using the background API
   * @param query The search query
   * @param options Optional search options
   * @returns Promise resolving to both local and semantic results
   */
  const searchHybrid = useCallback(async (query: string, options?: SearchOptions) => {
    if (!query || query.trim().length === 0) {
      return { localResults: [], semanticResults: [] };
    }
    
    try {
      const api = await getBackgroundAPI<BackgroundAPI>();
      const searchService = api.search; // Removed await - search is a direct object, not a Promise 
      const results = await searchService.searchHybrid(query, options);
      
      // Track this hybrid search
      const eventService = await api.events;
      await eventService.trackSearchPerformed(
        query, 
        results.localResults.length + results.semanticResults.length, 
        'hybrid'
      );
      
      return results;
    } catch (error) {
      console.error('[useBackgroundSearch] Hybrid search error:', error);
      return { localResults: [], semanticResults: [] };
    }
  }, []);

  /**
   * Track a search result click
   * @param resultId ID of the clicked result
   * @param position Position in the results list
   * @param url URL of the clicked result
   * @param query Search query that produced the result
   */
  const trackResultClick = useCallback(async (
    resultId: string,
    position: number,
    url: string,
    query: string
  ) => {
    try {
      const api = getBackgroundAPI<BackgroundAPI>();
      const eventService = await api.events;
      await eventService.trackSearchClick(
        searchSessionId,
        resultId,
        position,
        url,
        query
      );
    } catch (error) {
      console.error('[useBackgroundSearch] Error tracking result click:', error);
    }
  }, [searchSessionId]);
  
  return {
    searchLocal,
    searchSemantic,
    searchHybrid,
    trackResultClick,
    searchSessionId
  };
}


==========================================
FILE: src/pages/newtab/NewTab.tsx
==========================================

import React, { useState, useEffect, useRef } from 'react';
import NewTabSearchBar from '../../components/NewTabSearchBar';
import ClusterContainer from '../../components/ClusterContainer';
import ThemeToggle from '../../components/ThemeToggle';
import { useAuth } from '../../hooks/useBackgroundAuth';
import useBackgroundClustering from '../../hooks/useBackgroundClustering';
import { detectOS } from '../../utils/osUtils';
import './newtab.css';

/**
 * NewTab page component for the Dory extension.
 * Serves as a composition layer for the primary Dory components.
 */

const NewTab: React.FC = () => {
  // Track if search is active to conditionally show/hide clusters
  const [isSearchActive, setIsSearchActive] = useState(false);
  
  // Use our auth hook to manage authentication
  const { isAuthenticated, loading: authLoading, login } = useAuth();
  
  // Use our clustering hook to manage clusters
  const { 
    clusters: currentClusters, 
    previousClusters,
    loading: clustersLoading
  } = useBackgroundClustering();
  
  // State to toggle between current and previous clusters
  const [showPreviousClusters, setShowPreviousClusters] = useState(false);
  
  // Ref for the search bar wrapper to help with autofocus
  const searchBarWrapperRef = useRef<HTMLDivElement>(null);

  // Toggle between current and previous clusters
  const toggleClusterView = () => {
    if (previousClusters.length > 0) {
      setShowPreviousClusters(prev => !prev);
      console.log('[NewTab] Toggled to', !showPreviousClusters ? 'previous' : 'current', 'clusters');
    } else {
      console.log('[NewTab] No previous clusters available to toggle');
    }
  };

  // Handle keyboard shortcut commands
  useEffect(() => {
    const handleCommand = (command: string) => {
      if (command === 'toggle-cluster-view') {
        toggleClusterView();
      }
    };
    
    // Add command listener for keyboard shortcuts defined in manifest.json
    chrome.commands?.onCommand?.addListener(handleCommand);
    
    return () => {
      chrome.commands?.onCommand?.removeListener(handleCommand);
    };
  }, [previousClusters.length]);

  // Autofocus search input when authenticated
  useEffect(() => {
    if (isAuthenticated && searchBarWrapperRef.current) {
      const focusTimeoutId = setTimeout(() => {
        const inputElement = searchBarWrapperRef.current?.querySelector<HTMLInputElement>(
          'input[type="text"]'
        );
        if (inputElement) {
          inputElement.focus();
          console.log('[NewTab] Focused search input');
        }
      }, 100);

      return () => clearTimeout(focusTimeoutId);
    }
  }, [isAuthenticated]);

  // Show loading state while checking auth
  if (authLoading) {
    return (
      <div className="newtab-container">
        <div className="dory-container">
          <div className="dory-text">
            Dynamic Online Recall for You
          </div>
        </div>
        <div className="loading-indicator">
          <p>Loading...</p>
        </div>
        <ThemeToggle />
      </div>
    );
  }

  // Not authenticated - show login button
  if (!isAuthenticated) {
    return (
      <div className="newtab-container">
        <div className="dory-container">
          <div className="dory-text">
            Dynamic Online Recall for You
          </div>
        </div>
        <div className="search-bar-wrapper">
          <div className="google-button-container">
            <button 
              className="google-sign-in-button"
              onClick={() => {
                console.log('[NewTab] Sign in button clicked');
                login();
              }}
            >
              Sign in with Google
            </button>
          </div>
        </div>
        <ThemeToggle />
      </div>
    );
  }

  // Determine which clusters to display based on toggle state
  const displayClusters = showPreviousClusters ? previousClusters : currentClusters;

  // Authenticated - show regular content with search bar and clusters
  return (
    <div className="newtab-container">
      {/* DORY heading */}
      <div className="dory-container">
        <div className="dory-text">
          Dynamic Online Recall for You
        </div>
      </div>

      {/* Search section with search bar and helper text */}
      <div className="search-section">
        {/* Search bar wrapper */}
        <div className="search-bar-wrapper" ref={searchBarWrapperRef}>
          <NewTabSearchBar onSearchStateChange={setIsSearchActive} />
        </div>

        {/* Helper text for keyboard shortcut - OS specific */}
        <div className="shortcut-helper-text">
          Press {detectOS() === 'Mac OS' ? '⌘' : 'Ctrl'}+Shift+K to search from any page
        </div>
      </div>

      {/* Cluster container - only shown if search is not active AND we have clusters */}
      {!isSearchActive && displayClusters.length > 0 && (
        <div className="clusters-wrapper">
          <ClusterContainer clusters={displayClusters} />
        </div>
      )}

      {/* Theme toggle button */}
      <ThemeToggle />
    </div>
  );
};



export default NewTab;

==========================================
FILE: src/pages/newtab/index.tsx
==========================================

/**
 * @file index.tsx
 * Entry point for the New Tab page
 */

import React from 'react';
import { createRoot } from 'react-dom/client';
import { QueryClientProvider } from '@tanstack/react-query';
import { queryClient } from '../../background/queryClient';
import NewTab from './NewTab';
import './newtab.css';

document.addEventListener('DOMContentLoaded', () => {
  console.log('[NewTab] Initializing New Tab page');

  const container = document.getElementById('app-container');
  if (!container) {
    console.error('[NewTab] No #app-container found');
    return;
  }

  const root = createRoot(container);
  root.render(
    <React.StrictMode>
      <QueryClientProvider client={queryClient}>
        <NewTab />
      </QueryClientProvider>
    </React.StrictMode>
  );
});

==========================================
FILE: src/pages/newtab/newtab.css
==========================================

/* src/pages/newtab/newtab.css */

/* Global box model */
*, *::before, *::after {
  box-sizing: border-box;
}

:root {
  --bg-color: #ffffff;
  --text-color: #000000;
  --border-color: rgba(0, 0, 0, 0.3);
  --border-hover-color: rgba(0, 0, 0, 0.5);
  --border-focus-color: rgba(0, 0, 0, 0.8);
  --shadow-color: rgba(0, 0, 0, 0.1);
  --shadow-focus-color: rgba(0, 0, 0, 0.15);
  --icon-filter: invert(0);
  --dory-text-color: #000000; 
  --text-primary: var(--text-color);
  --text-secondary: rgba(0, 0, 0, 0.6);
  --item-hover-bg: rgba(0, 0, 0, 0.05);

  /* Secondary background for components */
  --bg-secondary: #f5f7fa;
  --bg-secondary-dark: #1e293b;
  
  /* Primary color for accents */
  --primary: #6366f1;
  --primary-light: #e0e7ff;
}

/* Dark mode */
html.dark-mode {
  --bg-color: #000000;
  --text-color: #ffffff;
  --border-color: rgba(255, 255, 255, 0.3);
  --border-hover-color: rgba(255, 255, 255, 0.5);
  --border-focus-color: rgba(255, 255, 255, 0.8);
  --shadow-color: rgba(255, 255, 255, 0.1);
  --shadow-focus-color: rgba(255, 255, 255, 0.15);
  --icon-filter: invert(1);
  --dory-text-color: #ffffff;
  --text-primary: var(--text-color);
  --text-secondary: rgba(255, 255, 255, 0.6);
  --item-hover-bg: rgba(255, 255, 255, 0.05);
}

body {
  margin: 0;
  padding: 0;
  background-color: var(--bg-color);
  color: var(--text-color);
  width: 100vw;
  height: 100vh;
  overflow-y: auto; 
  font-family: 'Cabinet Grotesk', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  transition: background-color 0.3s ease, color 0.3s ease;
}

/* Container for the entire NewTab page */
.newtab-container {
  width: 100%;
  height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  padding-top: 32.5vh; /* Keep initial vertical spacing */
}

/* DORY container & text */
.dory-container {
  width: 600px;
  max-width: 90%;
  text-align: center;
  margin-bottom: 24px;
  box-sizing: border-box;
}

/* Search section containing search bar and helper text */
.search-section {
  width: 600px;
  max-width: 90%;
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-bottom: 32px;
  box-sizing: border-box;
}

/* Wrapper for the search bar */
.search-bar-wrapper {
  width: 100%;
  box-sizing: border-box;
}

/* Helper text for keyboard shortcut */
.shortcut-helper-text {
  width: 100%;
  text-align: right; /* Right-aligned as requested */
  font-size: 0.75rem;
  color: var(--text-secondary);
  opacity: 0.7;
  font-weight: 400;
  margin-top: 8px;
  box-sizing: border-box;
  pointer-events: none; /* Ensure it doesn't interfere with clicks */
  padding-right: 16px; /* Add some right padding to match the search bar's internal padding */
}

/* Wrapper for the clusters */
.clusters-wrapper {
  width: 600px; /* Same width as search bar */
  max-width: 90%;
  box-sizing: border-box;
}

.dory-text {
  text-align: center;
  color: var(--dory-text-color);
  font-family: 'Cabinet Grotesk', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  font-weight: 500;
  font-size: 1.1rem;
  letter-spacing: 0.05em;
  transition: color 0.3s ease;
  margin: 0 auto;
  white-space: nowrap;
}

/* Media queries for responsive font sizing */
@media (min-width: 480px) {
  .dory-text {
    font-size: 1.4rem;
    letter-spacing: 0.075em;
  }
}

@media (min-width: 768px) {
  .dory-text {
    font-size: 1.7rem;
    letter-spacing: 0.1em;
  }
}

@media (min-width: 1024px) {
  .dory-text {
    font-size: 2rem;
  }
}

/* Removed any old .search-container or .results-list styling,
   because those are now in NewTabSearchBar.css */

/* The fixed footer or theme toggle is still allowed. */
.newtab-footer {
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  display: flex;
  justify-content: center;
  padding: 16px;
}

/* Loading indicator */
.loading-indicator {
  display: flex;
  justify-content: center;
  align-items: center;
  position: absolute;
  left: 50%;
  top: 42vh;
  transform: translateX(-50%);
  width: 600px;
  max-width: 90%;
}

/* Google button container */
.google-button-container {
  display: flex;
  justify-content: center;
  align-items: center;
  width: 100%;
}

/* Custom Google Sign In Button */
.google-sign-in-button {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  max-width: 240px;
  height: 40px;
  background-color: transparent;
  color: var(--text-color);
  border: 1px solid var(--border-color);
  border-radius: 14px;
  font-family: 'Cabinet Grotesk', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: border-color 0.3s, box-shadow 0.3s;
  padding: 0 16px;
  box-shadow: none;
  margin: 0 auto; /* Add auto margins to help with centering */
}

.google-sign-in-button:hover {
  border-color: var(--border-hover-color);
  box-shadow: 0 4px 8px var(--shadow-color);
}

.google-sign-in-button:focus {
  outline: none;
  border-color: var(--border-focus-color);
  box-shadow: 0 4px 8px var(--shadow-focus-color);
}

html.dark-mode .google-sign-in-button {
  background-color: transparent;
  color: var(--text-color);
  border: 1px solid var(--border-color);
}

/* Responsive adjustments for cluster positioning */
@media (max-width: 768px) {
  .clusters-wrapper {
    top: 50vh; /* Reduced from 52vh to maintain consistent spacing */
  }
}

@media (max-width: 480px) {
  .dory-container {
    top: 20vh;
  }
  
  .search-bar-wrapper {
    top: 30vh;
  }
  
  .clusters-wrapper {
    top: 38vh; /* Reduced from 42vh to maintain consistent spacing */
  }
}

==========================================
FILE: src/pages/newtab/newtab.html
==========================================

<!-- src/pages/newtab/newtab.html -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- This meta tag helps prevent Chrome from focusing on the address bar -->
    <meta name="chrome-focus-override" content="true" />
    <title>New Tab</title>
  </head>
  <body>
    <div id="app-container"></div>
    <script type="module" src="./index.tsx"></script>
  </body>
</html>

==========================================
FILE: src/pages/sidepanel/SidePanel.tsx
==========================================

/**
 * @file SidePanel.tsx
 * React UI for the Chrome side panel DORY authentication.
 */

import React from 'react';
import { useAuth } from '../../hooks/useBackgroundAuth';
import useBackgroundPreferences from '../../hooks/useBackgroundPreferences';

export default function SidePanel() {
  // Use our auth hook to manage authentication
  const { isAuthenticated, loading, login, logout } = useAuth();
  
  // Initialize theme preferences - automatically applies dark/light mode
  useBackgroundPreferences();

  const handleSignIn = () => {
    console.log('[SidePanel] Sign in button clicked');
    // Trigger login flow
    login(); 
  };

  const handleLogout = () => {
    // Trigger logout flow
    logout();
  };

  // Show loading state
  if (loading) {
    return (
      <div className="sidepanel-container">
        <div className="loading-indicator">
          <p>Loading...</p>
        </div>
      </div>
    );
  }

  // Not authenticated - show login
  if (!isAuthenticated) {
    return (
      <div className="sidepanel-container">
        <div className="user-section">
          <div className="dory-text">
            Dynamic Online Recall for You
          </div>
          <div className="google-button-container">
            <button 
              className="google-sign-in-button"
              onClick={handleSignIn}
            >
              Sign in with Google
            </button>
          </div>
        </div>
      </div>
    );
  }

  // Authenticated - show user info and logout button
  return (
    <div className="sidepanel-container">
      <div className="user-section">
        <div className="dory-text">
          Dynamic Online Recall for You
        </div>
        <div className="google-button-container">
          <button className="logout-button" onClick={handleLogout}>
            Logout
          </button>
        </div>
      </div>
      <div className="content-area">
        {/* Additional functionality can be added here in the future */}
      </div>
    </div>
  );
}


==========================================
FILE: src/pages/sidepanel/index.tsx
==========================================

/**
 * @file index.tsx
 * Entry point for the DORY side panel
 */

import React from 'react';
import { createRoot } from 'react-dom/client';
import { QueryClientProvider } from '@tanstack/react-query';
import { queryClient } from '../../background/queryClient';
import SidePanel from './SidePanel';
import './sidepanel.css';

console.log('[DORY] Side panel initializing...');

document.addEventListener('DOMContentLoaded', () => {
  const container = document.getElementById('app-container');
  if (!container) {
    console.error('[DORY] No #app-container found in side panel');
    return;
  }

  // Apply dark mode if preferred
  try {
    const storedTheme = localStorage.getItem('preferredTheme');
    if (storedTheme === 'dark' || 
        (!storedTheme && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
      document.body.classList.add('dark-mode');
    }
  } catch (err) {
    console.error('[DORY] Error checking theme preference:', err);
  }

  // Render the React app
  try {
    const root = createRoot(container);
    root.render(
      <React.StrictMode>
        <QueryClientProvider client={queryClient}>
          <SidePanel />
        </QueryClientProvider>
      </React.StrictMode>
    );
    console.log('[DORY] Side panel rendered successfully');
  } catch (err) {
    console.error('[DORY] Error rendering side panel:', err);
    container.innerHTML = '<div class="sidepanel-container"><p>Error loading side panel</p></div>';
  }
}); 

==========================================
FILE: src/pages/sidepanel/sidepanel.css
==========================================

/**
 * Side panel styling for DORY extension
 * This CSS is designed for the vertical nature of side panels
 */

:root {
  --dory-bg-light: #ffffff;
  --dory-text-light: #000000;
  --dory-bg-dark: #1e1e1e;
  --dory-text-dark: #ffffff;
  --dory-accent: #2196f3;
  --dory-button-bg: #2196f3;
  --dory-button-text: white;
  --dory-radius: 12px;
  --dory-spacing: 16px;
}

body {
  margin: 0;
  padding: 0;
  font-family: 'Cabinet Grotesk', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
  background-color: var(--dory-bg-light);
  color: var(--dory-text-light);
  transition: background-color 0.3s, color 0.3s;
  height: 100vh;
  overflow-y: auto;
}

body.dark-mode {
  background-color: var(--dory-bg-dark);
  color: var(--dory-text-dark);
}

#app-container {
  height: 100%;
  display: flex;
  flex-direction: column;
}

.sidepanel-container {
  display: flex;
  flex-direction: column;
  padding: var(--dory-spacing);
  height: 100%;
}

.user-section {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: var(--dory-spacing) 0;
  width: 100%;
}

/* Remove the now unused CSS for user name and avatar */

/* Share base styles between both buttons */
.google-sign-in-button,
.logout-button {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  max-width: 240px;
  height: 40px;
  background-color: transparent;
  color: var(--text-color, var(--dory-text-light));
  border: 1px solid var(--border-color, rgba(0, 0, 0, 0.3));
  border-radius: 14px;
  font-family: 'Cabinet Grotesk', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: border-color 0.3s, box-shadow 0.3s;
  padding: 0 16px;
  box-shadow: none;
  margin-top: 0;
}

.google-sign-in-button:hover,
.logout-button:hover {
  border-color: var(--border-hover-color, rgba(0, 0, 0, 0.5));
  box-shadow: 0 4px 8px var(--shadow-color, rgba(0, 0, 0, 0.1));
}

.google-sign-in-button:focus,
.logout-button:focus {
  outline: none;
  border-color: var(--border-focus-color, rgba(0, 0, 0, 0.8));
  box-shadow: 0 4px 8px var(--shadow-focus-color, rgba(0, 0, 0, 0.15));
}

body.dark-mode .google-sign-in-button,
body.dark-mode .logout-button {
  color: var(--text-color, var(--dory-text-dark));
  border: 1px solid var(--border-color, rgba(255, 255, 255, 0.3));
}

/* Only for the login button - separate styling */
.login-button {
  background-color: var(--dory-button-bg);
  color: var(--dory-button-text);
  border: none;
  border-radius: 14px;
  margin-top: var(--dory-spacing);
  padding: 0 16px;
  height: 40px;
  font-size: 14px;
  font-family: 'Cabinet Grotesk', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
  cursor: pointer;
}

.login-button:hover, 
.login-button:focus {
  opacity: 0.9;
}

.loading-indicator {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100%;
}

h3 {
  margin-top: 0;
  margin-bottom: var(--dory-spacing);
}

/* Media queries for responsive font sizing for the user info */
@media (min-width: 480px) {
  /* Removed user-info h3 styles */
}

@media (min-width: 768px) {
  /* Removed user-info h3 styles */
}

/* Ensure the side panel has enough content area */
.content-area {
  flex: 1;
  overflow-y: auto;
}

/* Media queries for potential responsive adjustments */
@media (max-width: 300px) {
  .sidepanel-container {
    padding: 12px;
  }
  /* Removed user-avatar styles */
}

/* Custom Google Sign In Button */
.google-sign-in-button {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  max-width: 240px;
  height: 40px;
  background-color: transparent;
  color: var(--text-color, var(--dory-text-light));
  border: 1px solid var(--border-color, rgba(0, 0, 0, 0.3));
  border-radius: 14px;
  font-family: 'Cabinet Grotesk', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: border-color 0.3s, box-shadow 0.3s;
  padding: 0 16px;
  box-shadow: none;
}

.google-sign-in-button:hover {
  border-color: var(--border-hover-color, rgba(0, 0, 0, 0.5));
  box-shadow: 0 4px 8px var(--shadow-color, rgba(0, 0, 0, 0.1));
}

.google-sign-in-button:focus {
  outline: none;
  border-color: var(--border-focus-color, rgba(0, 0, 0, 0.8));
  box-shadow: 0 4px 8px var(--shadow-focus-color, rgba(0, 0, 0, 0.15));
}

body.dark-mode .google-sign-in-button {
  background-color: transparent;
  color: var(--text-color, var(--dory-text-dark));
  border: 1px solid var(--border-color, rgba(255, 255, 255, 0.3));
}

/* Google button container */
.google-button-container {
  display: flex;
  justify-content: center;
  margin-top: var(--dory-spacing);
  width: 100%;
}

/* DORY text styling to match the new tab page */
.dory-text {
  text-align: center;
  color: var(--dory-text-light);
  font-family: 'Cabinet Grotesk', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  font-weight: 500;
  font-size: 1.1rem;
  letter-spacing: 0.05em;
  transition: color 0.3s ease;
  margin: 0 auto;
  white-space: nowrap;
  margin-bottom: var(--dory-spacing);
}

/* Media queries for responsive font sizing */
@media (min-width: 480px) {
  .dory-text {
    font-size: 1.4rem;
    letter-spacing: 0.075em;
  }
}

@media (min-width: 768px) {
  .dory-text {
    font-size: 1.7rem;
    letter-spacing: 0.1em;
  }
}

@media (min-width: 1024px) {
  .dory-text {
    font-size: 2rem;
  }
}

body.dark-mode .dory-text {
  color: var(--dory-text-dark);
} 

==========================================
FILE: src/pages/sidepanel/sidepanel.html
==========================================

<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DORY Side Panel</title>
  <link rel="stylesheet" href="sidepanel.css">
</head>
<body>
  <div id="app-container"></div>
  <script type="module" src="./index.tsx"></script>
</body>
</html> 

==========================================
FILE: src/pages/spotlight/SearchOverlay.tsx
==========================================

/**
 * @file SearchOverlay.tsx
 * React component for the global search overlay.
 * 
 * This component serves as a wrapper for the NewTabSearchBar,
 * adapting it for use in the content script overlay context.
 */

import React, { useEffect, useState } from 'react';
import NewTabSearchBar from '../../components/NewTabSearchBar';

interface SearchOverlayProps {
  onClose: () => void;
}

/**
 * SearchOverlay component that adapts the NewTabSearchBar for use in the
 * global search overlay context.
 */
export default function SearchOverlay({ onClose }: SearchOverlayProps) {
  const [isSearchActive, setIsSearchActive] = useState(false);
  
  // Add keyboard listener for ESC to close
  useEffect(() => {
    console.log('[DORY] SearchOverlay component mounted');
    
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        onClose();
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [onClose]);

  return (
    <div className="spotlight-search" data-active={isSearchActive}>
      <NewTabSearchBar onSearchStateChange={setIsSearchActive} />
    </div>
  );
} 

==========================================
FILE: src/pages/spotlight/spotlight.css
==========================================

/* 
 * DORY SPOTLIGHT SEARCH STYLES
 */

/* Spotlight search container - only handles positioning */
.spotlight-search {
  width: 600px;
  max-width: 90%;
  margin: 0 auto;
  display: flex;
  flex-direction: column;
  overflow: visible;
}

/* Ensure the search container takes the full width */
.spotlight-search .search-container {
  width: 100%;
}

/* Ensure results list appears properly in the overlay */
.spotlight-search .results-list {
  max-height: 50vh; /* Limit height in the overlay context */
} 

==========================================
FILE: src/services/authService.ts
==========================================

/**
 * @file authService.ts
 * Background-only authentication service for the Dory extension.
 */

import { API_BASE_URL, AUTH_ENDPOINTS, STORAGE_KEYS } from '../config';
import { AuthState, TokenResponse, User } from '../types';

export class AuthService {
  private authState: AuthState = {
    isAuthenticated: false,
    user: null,
    accessToken: null,
    refreshToken: null,
  };
  private stateChangeListeners: Array<(newState: AuthState) => void> = [];
  private isInitialized = false;

  constructor() {
    console.log('[AuthService] Instance created.');
  }

  /**
   * Initializes auth state from storage. Optionally verifies token.
   */
  public async init(): Promise<void> {
    if (this.isInitialized) return;
    await this.loadStateFromStorage();
    if (this.authState.accessToken) await this.verifyToken();
    this.isInitialized = true;
  }

  /**
   * Starts the Google OAuth flow (ID Token retrieval).
   */
  public async login(): Promise<void> {
    try {
      console.log('[AuthService] Starting OAuth flow...');
      
      // Get client ID directly from the manifest - proven working method
      const manifest = chrome.runtime.getManifest();
      const clientId = manifest.oauth2?.client_id;
      const scopes = manifest.oauth2?.scopes || ['email', 'profile', 'openid'];
      
      if (!clientId) {
        console.error('[AuthService] OAuth client ID not found in manifest');
        throw new Error('OAuth client ID not found in manifest');
      }
      
      console.log('[AuthService] Using client ID from manifest');
      
      // Use the Chrome-specific redirect URI format
      const redirectUrl = `https://${chrome.runtime.id}.chromiumapp.org/`;
      
      const authUrl = new URL('https://accounts.google.com/o/oauth2/v2/auth');
      authUrl.searchParams.set('client_id', clientId);
      authUrl.searchParams.set('redirect_uri', redirectUrl);
      authUrl.searchParams.set('response_type', 'id_token');
      authUrl.searchParams.set('scope', scopes.join(' '));
      authUrl.searchParams.set('nonce', Math.random().toString(36).slice(2));
      authUrl.searchParams.set('prompt', 'consent select_account');
      
      console.log('[AuthService] Auth URL prepared, launching flow...');

      // Use Promise wrapper around callback pattern for better error handling
      const responseUrl = await new Promise<string>((resolve, reject) => {
        chrome.identity.launchWebAuthFlow(
          { url: authUrl.toString(), interactive: true },
          (responseUrl) => {
            if (chrome.runtime.lastError) {
              console.error('[AuthService] Chrome error:', chrome.runtime.lastError.message);
              reject(new Error(chrome.runtime.lastError.message));
              return;
            }
            if (!responseUrl) {
              console.error('[AuthService] No response URL');
              reject(new Error('No response URL'));
              return;
            }
            resolve(responseUrl);
          }
        );
      });
      
      console.log('[AuthService] Got response URL');
      if (!responseUrl) throw new Error('Authentication flow cancelled or failed.');

      const urlFragment = responseUrl.split('#')[1] || '';
      const params = new URLSearchParams(urlFragment);
      const idToken = params.get('id_token');
      if (!idToken) throw new Error(`OAuth failed: ${params.get('error') || 'No token'}`);

      await this.exchangeGoogleIdToken(idToken);
    } catch (err) {
      console.error('[AuthService] Login flow failed:', err);
    }
  }

  /**
   * Logs the user out and calls the backend logout endpoint if possible.
   */
  public async logout(): Promise<void> {
    const token = this.authState.accessToken;
    this.updateAuthState({
      isAuthenticated: false,
      user: null,
      accessToken: null,
      refreshToken: null,
    });
    await this.saveStateToStorage();
    if (token) {
      try {
        // Directly call logout endpoint with the old token
        await fetch(`${API_BASE_URL}${AUTH_ENDPOINTS.LOGOUT}`, {
          method: 'POST',
          headers: { Authorization: `Bearer ${token}` },
        });
      } catch (err) {
        console.warn('[AuthService] Backend logout error:', err);
      }
    }
  }

  public getAuthState(): AuthState {
    return { ...this.authState };
  }

  public onStateChange(listener: (newState: AuthState) => void): () => void {
    this.stateChangeListeners.push(listener);
    return () => {
      this.stateChangeListeners = this.stateChangeListeners.filter(l => l !== listener);
    };
  }

  /**
   * Verifies the token by calling /me. Refreshes if necessary.
   */
  public async verifyToken(): Promise<boolean> {
    if (!this.authState.accessToken) return false;
    try {
      const user = await this.makeRequest<User>(AUTH_ENDPOINTS.ME, { method: 'GET' });
      if (user?.id) {
        this.updateAuthState({ user });
        return true;
      }
      return false;
    } catch (err) {
      console.warn('[AuthService] Token verification failed:', (err as Error).message);
      return false;
    }
  }

  // --- Private Methods ---

  private notifyListeners(): void {
    const stateCopy = { ...this.authState };
    this.stateChangeListeners.forEach(listener => listener(stateCopy));
  }

  private updateAuthState(newState: Partial<AuthState>): void {
    this.authState = { ...this.authState, ...newState };
    this.notifyListeners();
  }

  private async loadStateFromStorage(): Promise<void> {
    try {
      const result = await chrome.storage.local.get(STORAGE_KEYS.AUTH_STATE);
      const loaded = result[STORAGE_KEYS.AUTH_STATE];
      if (loaded && typeof loaded === 'object') {
        this.updateAuthState({
          ...loaded,
          isAuthenticated: !!loaded.isAuthenticated,
        });
      }
    } catch (err) {
      console.error('[AuthService] Failed to load state:', err);
    }
  }

  private async saveStateToStorage(): Promise<void> {
    try {
      await chrome.storage.local.set({ [STORAGE_KEYS.AUTH_STATE]: this.authState });
    } catch (err) {
      console.error('[AuthService] Failed to save state:', err);
    }
  }

  private async makeRequest<T>(
    endpoint: string,
    options: RequestInit = {},
    needsAuth = true
  ): Promise<T> {
    let { accessToken, refreshToken } = this.authState;

    if (needsAuth && !accessToken) {
      throw new Error('Authentication required, but no access token is set.');
    }
    options.headers = {
      ...(options.headers || {}),
      'Content-Type': 'application/json',
      ...(needsAuth ? { Authorization: `Bearer ${accessToken}` } : {}),
    };
    options.credentials = 'include';

    let response = await fetch(`${API_BASE_URL}${endpoint}`, options);

    // Attempt refresh if 401
    if (needsAuth && response.status === 401 && refreshToken) {
      const refreshed = await this.refreshToken();
      if (refreshed) {
        accessToken = this.authState.accessToken;
        options.headers = {
          ...options.headers,
          Authorization: `Bearer ${accessToken}`,
        };
        response = await fetch(`${API_BASE_URL}${endpoint}`, options);
      } else {
        await this.logout();
        throw new Error('Authentication failed: Unable to refresh token.');
      }
    }

    if (!response.ok) {
      const errorData = await response.text();
      const error = new Error(`API Error: ${response.statusText}`);
      (error as any).status = response.status;
      (error as any).data = errorData;
      throw error;
    }

    return response.status === 204 ? null as T : (response.json() as Promise<T>);
  }

  private async exchangeGoogleIdToken(idToken: string): Promise<void> {
    const tokenResponse = await this.makeRequest<TokenResponse>(
      AUTH_ENDPOINTS.TOKEN,
      {
        method: 'POST',
        body: JSON.stringify({ id_token: idToken }),
      },
      false
    );
    if (!tokenResponse.access_token || !tokenResponse.user) {
      throw new Error('Invalid token exchange response.');
    }
    this.updateAuthState({
      isAuthenticated: true,
      user: tokenResponse.user,
      accessToken: tokenResponse.access_token,
      refreshToken: tokenResponse.refresh_token || null,
    });
    await this.saveStateToStorage();
  }

  private async refreshToken(): Promise<boolean> {
    const { refreshToken } = this.authState;
    if (!refreshToken) return false;

    try {
      const tokenResponse = await this.makeRequest<TokenResponse>(
        AUTH_ENDPOINTS.REFRESH,
        {
          method: 'POST',
          body: JSON.stringify({ refresh_token: refreshToken }),
        },
        false
      );
      if (!tokenResponse.access_token || !tokenResponse.user) {
        throw new Error('Invalid refresh response.');
      }
      this.updateAuthState({
        isAuthenticated: true,
        user: tokenResponse.user,
        accessToken: tokenResponse.access_token,
        refreshToken: tokenResponse.refresh_token || refreshToken,
      });
      await this.saveStateToStorage();
      return true;
    } catch (err: any) {
      console.warn('[AuthService] Refresh failed:', err.message || err);
      if (err.status === 401 || `${err}`.includes('Invalid')) await this.logout();
      return false;
    }
  }
}

export const authService = new AuthService();

==========================================
FILE: src/services/clusteringService.ts
==========================================

/**
 * @file clusteringService.ts
 *
 * Service for interacting with the clustering API.
 * Provides methods to fetch cluster data and trigger clustering.
 */

import { API_BASE_URL, CLUSTERING_ENDPOINTS, STORAGE_KEYS } from '../config';
import { authService } from './authService';
import { ClusterSuggestion, ClusterResponse } from '../types';

/**
 * Service for retrieving and managing cluster suggestions.
 * Handles communication with the clustering API and local caching.
 */
class ClusteringService {
  /**
   * Get cluster suggestions with history tracking.
   * This method combines fetching and caching in one simple API.
   * 
   * @param options.forceRefresh Force a refresh from the server (default: false)
   * @param options.count Number of clusters to fetch (default: 3)
   * @returns Promise resolving to current and previous clusters
   */
  async getClusterSuggestions(options: {
    forceRefresh?: boolean;
    count?: number;
  } = {}): Promise<{
    current: ClusterSuggestion[];
    previous: ClusterSuggestion[];
  }> {
    try {
      const { forceRefresh = false, count = 3 } = options;
      
      // Check if we need to fetch fresh data
      let needsFresh = forceRefresh;
      let current: ClusterSuggestion[] = [];
      let previous: ClusterSuggestion[] = [];
      
      if (!needsFresh) {
        // Get from storage
        const storage = await chrome.storage.local.get(STORAGE_KEYS.CLUSTER_HISTORY_KEY);
        const history = storage[STORAGE_KEYS.CLUSTER_HISTORY_KEY];
        
        if (history && history.timestamp) {
          // Use cached data if it's less than 5 minutes old
          const isFresh = (Date.now() - history.timestamp) < 5 * 60 * 1000; // 5 minutes
          
          if (isFresh) {
            console.log('[ClusteringService] Using cached clusters');
            return {
              current: history.current || [],
              previous: history.previous || []
            };
          } else {
            // Data is stale but we'll preserve current as previous
            previous = history.current || [];
            needsFresh = true;
          }
        } else {
          // No cache exists
          needsFresh = true;
        }
      }
      
      if (needsFresh) {
        // Fetch fresh data from server
        console.log('[ClusteringService] Fetching fresh clusters');
        current = await this.fetchClusterSuggestions(count);
        
        // Store in storage
        await chrome.storage.local.set({
          [STORAGE_KEYS.CLUSTER_HISTORY_KEY]: {
            current,
            previous,
            timestamp: Date.now()
          }
        });
        
        console.log('[ClusteringService] Updated cluster history');
      }
      
      return { current, previous };
    } catch (error) {
      console.error('[ClusteringService] Error getting clusters:', error);
      return { current: [], previous: [] };
    }
  }

  /**
   * Fetch cluster suggestions for the current user.
   * 
   * @param count Number of clusters to fetch (default: 3)
   * @returns Promise resolving to an array of full ClusterSuggestion objects
   */
  async fetchClusterSuggestions(count: number = 3): Promise<ClusterSuggestion[]> {
    try {
      const authState = await authService.getAuthState();
      const userId = authState.user?.id;
      
      if (!userId) {
        console.warn('[ClusteringService] No authenticated user, cannot fetch clusters');
        return [];
      }

      const endpoint = `${CLUSTERING_ENDPOINTS.SUGGESTIONS}?user_id=${userId}&count=${count}`;
      console.log('[ClusteringService] Fetching clusters from:', endpoint);

      const response = await fetch(`${API_BASE_URL}${endpoint}`, {
        headers: {
          'Authorization': `Bearer ${authState.accessToken}`
        }
      });
      
      if (!response.ok) {
        throw new Error(`Error fetching clusters: ${response.statusText}`);
      }
      
      const data: ClusterResponse = await response.json();
      return data.suggestions;
    } catch (error) {
      console.error('[ClusteringService] Error fetching clusters:', error);
      return [];
    }
  }

  /**
   * Trigger the clustering process for the current user.
   * This is typically used to force a refresh of the clusters.
   */
  async triggerClustering(): Promise<boolean> {
    try {
      const authState = await authService.getAuthState();
      const userId = authState.user?.id;
      
      if (!userId) {
        console.warn('[ClusteringService] No authenticated user, cannot trigger clustering');
        return false;
      }

      const endpoint = `${CLUSTERING_ENDPOINTS.SUGGESTIONS}?user_id=${userId}&trigger=true`;
      console.log('[ClusteringService] Triggering clustering for user:', userId);

      const response = await fetch(`${API_BASE_URL}${endpoint}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${authState.accessToken}`
        }
      });
      
      if (!response.ok) {
        throw new Error(`Error triggering clustering: ${response.statusText}`);
      }
      
      console.log('[ClusteringService] Clustering triggered successfully');
      return true;
    } catch (error) {
      console.error('[ClusteringService] Error triggering clustering:', error);
      return false;
    }
  }
}

// Create and export a singleton instance
export const clusteringService = new ClusteringService();

// Default export for convenience
export default ClusteringService;

==========================================
FILE: src/services/coldStorageService.ts
==========================================

/**
 * @file coldStorageSync.ts
 * 
 * Cold Storage Sync Service
 * Runs every 5 minutes to batch-upload data from IndexedDB to the backend.
 * Uses the repository pattern for database access and clean architecture principles.
 */

// Configuration and constants
import { 
  API_BASE_URL, 
  COLD_STORAGE_ENDPOINTS, 
  COLD_STORAGE_CONFIG, 
  STORAGE_KEYS,
  DEBUG 
} from '../config';

// Repositories and types
import { 
  pageRepository, 
  visitRepository, 
  sessionRepository,
  eventRepository,
  EventType
} from '../db/repositories';

// Services
import { authService } from './authService';

// Sync sources - keeping this as local since it's specific to this service's implementation
const SYNC_SOURCE = {
  ALARM: 'alarm',
  SESSION_END: 'session_end',
  MANUAL: 'manual'
};

/**
 * A class that orchestrates cold-storage syncing in a background context.
 * In Manifest V3, you likely won't keep it instantiated; rather,
 * you might create it on-demand in your service worker or have a static usage.
 */
export class ColdStorageSync {
  private isSyncing = false;
  private syncSource: string = SYNC_SOURCE.MANUAL;
  private totalSyncedRecords: number = 0;
  private syncStartTime: number = 0;

  constructor(source?: string) {
    this.syncSource = source || SYNC_SOURCE.MANUAL;
    console.log(`[ColdStorageSync] Service constructed, source: ${this.syncSource}`);
  }

  /**
   * Initialize 5-minute interval alarm-based scheduling for MV3
   * (called from the background service worker).
   */
  public static initializeScheduling(): void {
    // Clear any old alarm
    chrome.alarms.clear('doryColdStorageSync');
    // Create a new daily alarm
    chrome.alarms.create('doryColdStorageSync', {
      periodInMinutes: COLD_STORAGE_CONFIG.SYNC_INTERVAL_MINUTES,
      when: Date.now() + 60_000 // start ~1 min from now
    });
    console.log('[ColdStorageSync] Alarm scheduled for 5-minute sync intervals');
  }

  /**
   * This is your main entry point from the alarm listener or a manual trigger.
   */
  public async performSync(): Promise<void> {
    if (this.isSyncing) {
      console.log('[ColdStorageSync] Sync already in progress; skipping');
      return;
    }

    // Check if circuit breaker is open
    if (await this.isCircuitOpen()) {
      console.log('[ColdStorageSync] Circuit breaker open, skipping sync operation');
      return;
    }

    try {
      this.isSyncing = true;
      this.syncStartTime = Date.now();
      this.totalSyncedRecords = 0;
      
      console.log(`[ColdStorageSync] Starting sync operation... (source: ${this.syncSource})`);

      // Get the current database statistics for logging
      try {
        const [pageCount, visitCount, sessionCount, eventCount] = await Promise.all([
          pageRepository.getCount(),
          visitRepository.getCount(),
          sessionRepository.getCount(),
          eventRepository.getCount()
        ]);
        
        console.log(
          `[ColdStorageSync] Database status - ` +
          `Pages: ${pageCount}, Visits: ${visitCount}, ` +
          `Sessions: ${sessionCount}, Events: ${eventCount}`
        );
      } catch (dbErr) {
        console.warn('[ColdStorageSync] Could not get database statistics:', dbErr);
      }

      // Perform the sync
      await this.syncData();

      // Record successful completion
      await chrome.storage.local.set({ [STORAGE_KEYS.LAST_SYNC_KEY]: Date.now() });
      
      const syncDuration = Date.now() - this.syncStartTime;
      console.log(
        `[ColdStorageSync] Sync completed successfully in ${syncDuration}ms, ` +
        `synced ${this.totalSyncedRecords} records`
      );
      
      // Update circuit breaker and telemetry for success
      await this.recordSyncSuccess();
    } catch (error) {
      console.error('[ColdStorageSync] Sync failed:', error);
      
      // Report serious errors more prominently
      console.error('==========================================');
      console.error('DORY COLD STORAGE SYNC FAILED');
      if (error instanceof TypeError && error.message.includes('fetch')) {
        console.error('Network error - check internet connection');
      } else if (error instanceof Error && error.message.includes('HTTP 401')) {
        console.error('Authentication error - user may need to log in again');
      } else if (error instanceof Error && error.message.includes('HTTP 5')) {
        console.error('Server error - backend service may be down');
      }
      console.error('Error details:', error);
      console.error('==========================================');
      
      // Record failure in circuit breaker
      await this.recordSyncFailure(error);
    } finally {
      this.isSyncing = false;
    }
  }

  /**
   * The core logic that fetches data from Dexie and sends it in batches.
   */
  private async syncData(): Promise<void> {
    // Get last sync time from chrome.storage.local
    const store = await chrome.storage.local.get(STORAGE_KEYS.LAST_SYNC_KEY);
    const lastSyncTime: number = store[STORAGE_KEYS.LAST_SYNC_KEY] ?? 0;

    // Current user ID for stamping records
    const userId = await this.getCurrentUserId();

    // First sync visits to have the data available for page duration calculations
    {
      const visits = await visitRepository.getVisitsAfterTime(lastSyncTime);

      // Create map of page durations using visit data
      const pageDurations: Record<string, number> = {};
      
      // Calculate total duration for each page by summing its visits
      for (const visit of visits) {
        const pageId = visit.pageId;
        const visitDuration = (visit.endTime || Date.now()) - visit.startTime;
        pageDurations[pageId] = (pageDurations[pageId] || 0) + visitDuration;
      }

      await this.syncCollection('visits', visits, userId);
      
      // Now sync pages with accurate duration data
      const pages = await pageRepository.getPagesUpdatedAfterTime(lastSyncTime);

      // Enhance pages with duration data before syncing
      const pagesWithDuration = pages.map(page => ({
        ...page,
        // Add calculated totalDuration if available, or fall back to estimate
        calculatedTotalDuration: pageDurations[page.pageId] || (page.lastVisit - page.firstVisit)
      }));

      await this.syncCollection('pages', pagesWithDuration, userId);
    }

    // sessions, events, search clicks, etc.
    {
      const sessions = await sessionRepository.getSessionsAfterTime(lastSyncTime);
      await this.syncCollection('sessions', sessions, userId);
    }

    // Example: sync search click events
    {
      const clickEvents = await eventRepository.getEventsByTypeAfterTime(
        EventType.SEARCH_RESULT_CLICKED, 
        lastSyncTime
      );
      await this.syncEvents(EventType.SEARCH_RESULT_CLICKED, clickEvents, userId);
    }

    // Add more collections as needed...
  }

  /**
   * Get the current user ID, throws error if not authenticated
   */
  private async getCurrentUserId(): Promise<string> {
    const authState = authService.getAuthState();
    if (!authState.isAuthenticated || !authState.user?.id) {
      throw new Error('User not authenticated');
    }
    return authState.user.id;
  }

  /**
   * Sync a collection by splitting into BATCH_SIZE chunks and sending.
   */
  private async syncCollection(collectionName: string, records: any[], userId: string): Promise<void> {
    if (!records.length) {
      console.log(`[ColdStorageSync] No new ${collectionName} records to sync`);
      return;
    }
    console.log(`[ColdStorageSync] Syncing ${records.length} ${collectionName} records`);

    const enriched = records.map(r => ({ ...r, userId: r.userId || userId }));
    let syncedCount = 0;

    for (let i = 0; i < enriched.length; i += COLD_STORAGE_CONFIG.BATCH_SIZE) {
      const batch = enriched.slice(i, i + COLD_STORAGE_CONFIG.BATCH_SIZE);
      
      try {
        const batchStartTime = Date.now();
        await this.sendBatch(collectionName, batch);
        const batchDuration = Date.now() - batchStartTime;
        
        syncedCount += batch.length;
        this.totalSyncedRecords += batch.length;
        
        console.log(
          `[ColdStorageSync] Synced ${collectionName} batch ` +
          `${Math.floor(i / COLD_STORAGE_CONFIG.BATCH_SIZE) + 1}/${Math.ceil(enriched.length / COLD_STORAGE_CONFIG.BATCH_SIZE)} ` +
          `(${batch.length} records in ${batchDuration}ms)`
        );
      } catch (error: any) {
        console.error(`[ColdStorageSync] Error syncing ${collectionName} batch:`, error);
        
        // Check if we should stop entirely or continue with next batch
        if (error.message?.includes('HTTP 401') || error.message?.includes('HTTP 403')) {
          throw new Error(`Authentication error during ${collectionName} sync: ${error.message}`);
        }
        
        // For server errors, we'll throw to abort the entire sync
        if (error.message?.includes('HTTP 5')) {
          throw new Error(`Server error during ${collectionName} sync: ${error.message}`);
        }
        
        // For other errors, log but continue with next batch
        console.warn(`[ColdStorageSync] Continuing with next batch despite error in ${collectionName} sync`);
      }
    }
    
    console.log(
      `[ColdStorageSync] Completed ${collectionName} sync: ` +
      `${syncedCount}/${records.length} records synchronized`
    );
  }

  /**
   * Actually POST a batch of data to your cold-storage endpoints.
   */
  private async sendBatch(collectionName: string, batch: any[]): Promise<void> {
    if (!batch.length) return;

    let endpoint: string;
    let transformed: any[];

    switch (collectionName) {
      case 'sessions':
        endpoint = COLD_STORAGE_ENDPOINTS.SESSIONS;
        transformed = batch.map(s => ({
          sessionId: String(s.sessionId),
          userId: s.userId,
          startTime: s.startTime,
          endTime: s.endTime ?? null,
          totalActiveTime: s.totalActiveTime,
          isActive: s.isActive
        }));
        break;

      case 'visits':
        endpoint = COLD_STORAGE_ENDPOINTS.VISITS;
        transformed = batch.map(v => ({
          visitId: String(v.visitId),
          userId: v.userId,
          pageId: String(v.pageId),
          sessionId: String(v.sessionId),
          startTime: Math.floor(v.startTime),
          endTime: v.endTime ? Math.floor(v.endTime) : null,
          totalActiveTime: Math.floor(v.totalActiveTime),
          fromPageId: v.fromPageId ?? null,
          isBackNavigation: !!v.isBackNavigation
        }));
        break;

      case 'pages':
        endpoint = COLD_STORAGE_ENDPOINTS.PAGES;
        transformed = batch.map(p => ({
          pageId: String(p.pageId),
          userId: p.userId,
          url: p.url,
          title: p.title,
          domain: p.domain,
          firstVisit: Math.floor(p.firstVisit),
          lastVisit: Math.floor(p.lastVisit),
          visitCount: p.visitCount,
          totalActiveTime: Math.floor(p.totalActiveTime),
          totalDuration: Math.floor(p.calculatedTotalDuration),
          lastModified: Math.floor(p.updatedAt)
        }));
        break;

      default:
        // Generic fallback if you have a catch-all
        endpoint = `${COLD_STORAGE_ENDPOINTS.BASE}/${collectionName}`;
        transformed = batch;
    }

    // Debug
    if (DEBUG) {
      console.log(`[ColdStorageSync] POSTing ${transformed.length} ${collectionName} items to ${endpoint}`, 
        transformed.length > 5 
          ? [transformed[0], '(...omitted...)', transformed[transformed.length - 1]]
          : transformed
      );
    }

    // Send
    const response = await fetch(`${API_BASE_URL}${endpoint}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'include',
      body: JSON.stringify(transformed)
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status} from server: ${response.statusText}`);
    }
    const respData = await response.json();
    console.log(`[ColdStorageSync] Synced batch => server ack:`, respData);
  }

  /**
   * Sync events of a specific type, e.g. SEARCH_CLICK
   */
  private async syncEvents(eventType: EventType, events: any[], userId: string): Promise<void> {
    if (!events.length) {
      console.log(`[ColdStorageSync] No ${eventType} events to sync`);
      return;
    }
    console.log(`[ColdStorageSync] Syncing ${events.length} ${eventType} events`);

    const enriched = events.map(e => ({ ...e, userId: e.userId || userId }));

    for (let i = 0; i < enriched.length; i += COLD_STORAGE_CONFIG.BATCH_SIZE) {
      const batch = enriched.slice(i, i + COLD_STORAGE_CONFIG.BATCH_SIZE);
      if (eventType === EventType.SEARCH_RESULT_CLICKED) {
        await this.sendSearchClickBatch(batch);
      } else {
        console.warn(`[ColdStorageSync] No direct sync logic for ${eventType}, skipping`);
      }
      console.log(`[ColdStorageSync] Synced ${eventType} batch ${Math.floor(i / COLD_STORAGE_CONFIG.BATCH_SIZE) + 1}/${Math.ceil(enriched.length / COLD_STORAGE_CONFIG.BATCH_SIZE)}`);
    }
  }

  /**
   * Example specialized method for search click events
   */
  private async sendSearchClickBatch(events: any[]): Promise<void> {
    const endpoint = COLD_STORAGE_ENDPOINTS.SEARCH_CLICKS;
    const transformed = events.map(e => ({
      clickId: `click_${e.data?.searchSessionId}_${e.data?.pageId}_${e.timestamp}`,
      userId: e.userId,
      pageId: e.data?.pageId,
      query: e.data?.query,
      position: e.data?.position,
      timestamp: e.timestamp
      // etc...
    }));

    if (DEBUG) {
      console.log('[ColdStorageSync] Posting search clicks =>', transformed);
    }

    const response = await fetch(`${API_BASE_URL}${endpoint}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'include',
      body: JSON.stringify(transformed)
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status} from server: ${response.statusText}`);
    }
    const data = await response.json();
    console.log(`[ColdStorageSync] Synced search clicks => server ack:`, data);
  }

  /**
   * Checks if the circuit breaker is open (too many failures recently)
   */
  private async isCircuitOpen(): Promise<boolean> {
    const circuitData = await chrome.storage.local.get(STORAGE_KEYS.CIRCUIT_BREAKER_KEY);
    const breakerState = circuitData[STORAGE_KEYS.CIRCUIT_BREAKER_KEY];
    
    if (!breakerState) return false;
    
    // If we've had too many failures and we're within the reset time window
    if (
      breakerState.failureCount >= COLD_STORAGE_CONFIG.MAX_CONSECUTIVE_FAILURES && 
      Date.now() - breakerState.lastFailure < COLD_STORAGE_CONFIG.CIRCUIT_RESET_TIME_MS
    ) {
      console.log(`[ColdStorageSync] Circuit breaker open: ${breakerState.failureCount} consecutive failures`);
      return true;
    }
    
    // If the circuit reset time has passed, we can close the circuit
    if (Date.now() - breakerState.lastFailure >= COLD_STORAGE_CONFIG.CIRCUIT_RESET_TIME_MS) {
      console.log('[ColdStorageSync] Circuit breaker reset time reached, closing circuit');
      await this.resetCircuitBreaker();
    }
    
    return false;
  }
  
  /**
   * Record a failure in the circuit breaker
   */
  private async recordSyncFailure(error: any): Promise<void> {
    const circuitData = await chrome.storage.local.get(STORAGE_KEYS.CIRCUIT_BREAKER_KEY);
    const breakerState = circuitData[STORAGE_KEYS.CIRCUIT_BREAKER_KEY] || { failureCount: 0, lastFailure: 0 };
    
    breakerState.failureCount += 1;
    breakerState.lastFailure = Date.now();
    breakerState.lastError = error?.message || String(error);
    
    await chrome.storage.local.set({ [STORAGE_KEYS.CIRCUIT_BREAKER_KEY]: breakerState });
    
    console.error(
      `[ColdStorageSync] Recorded sync failure #${breakerState.failureCount}: ${breakerState.lastError}`
    );
    
    // Update telemetry for failures
    await this.updateTelemetry(false, 0, error);
  }
  
  /**
   * Record a successful sync in the circuit breaker (resets failure count)
   */
  private async recordSyncSuccess(): Promise<void> {
    await chrome.storage.local.set({ 
      [STORAGE_KEYS.CIRCUIT_BREAKER_KEY]: { 
        failureCount: 0, 
        lastFailure: 0,
        lastSuccess: Date.now()
      } 
    });
    
    // Update telemetry for success
    await this.updateTelemetry(true, this.totalSyncedRecords);
  }
  
  /**
   * Reset the circuit breaker
   */
  private async resetCircuitBreaker(): Promise<void> {
    await chrome.storage.local.set({ 
      [STORAGE_KEYS.CIRCUIT_BREAKER_KEY]: { 
        failureCount: 0, 
        lastFailure: 0 
      } 
    });
    console.log('[ColdStorageSync] Circuit breaker reset');
  }
  
  /**
   * Track telemetry data about sync operations
   */
  private async updateTelemetry(
    success: boolean, 
    recordCount: number, 
    error?: any
  ): Promise<void> {
    const telemetryData = await chrome.storage.local.get(STORAGE_KEYS.TELEMETRY_KEY);
    const telemetry = telemetryData[STORAGE_KEYS.TELEMETRY_KEY] || {
      totalSyncs: 0,
      successfulSyncs: 0,
      failedSyncs: 0,
      recordsSynced: 0,
      lastSync: 0,
      syncSources: {}
    };
    
    // Update counts
    telemetry.totalSyncs += 1;
    if (success) {
      telemetry.successfulSyncs += 1;
      telemetry.recordsSynced += recordCount;
    } else {
      telemetry.failedSyncs += 1;
      telemetry.lastError = error?.message || String(error);
    }
    
    // Track by source
    telemetry.syncSources[this.syncSource] = 
      (telemetry.syncSources[this.syncSource] || 0) + 1;
    
    // Track timing
    const syncDuration = Date.now() - this.syncStartTime;
    telemetry.lastSync = Date.now();
    telemetry.lastSyncDuration = syncDuration;
    
    await chrome.storage.local.set({ [STORAGE_KEYS.TELEMETRY_KEY]: telemetry });
  }
}

/**
 * In your background service worker, you might do:
 *
 *  import { ColdStorageSync } from './coldStorageSync';
 *
 *  // On extension startup:
 *  ColdStorageSync.initializeScheduling();
 *
 *  // On alarm (every 5 minutes):
 *  chrome.alarms.onAlarm.addListener(alarm => {
 *    if (alarm.name === 'doryColdStorageSync') {
 *      const syncer = new ColdStorageSync('alarm');
 *      syncer.performSync();
 *    }
 *  });
 */

// Export a singleton creator function to easily create a new instance with a source parameter
export const createColdStorageSyncer = (source?: string) => new ColdStorageSync(source);

// Export a default singleton for backward compatibility
export const coldStorageSync = new ColdStorageSync();

/**
 * Utility for development: resets the circuit breaker to allow sync to try again
 * after fixing schema issues.
 */
export async function resetColdStorageSyncCircuitBreaker(): Promise<void> {
  await chrome.storage.local.set({ 
    [STORAGE_KEYS.CIRCUIT_BREAKER_KEY]: { 
      failureCount: 0, 
      lastFailure: 0,
      lastSuccess: Date.now() 
    } 
  });
  console.log('[ColdStorageSync] Circuit breaker has been reset');
}

/**
 * Manually trigger a cold storage sync for testing purposes
 */
export async function triggerManualColdStorageSync(): Promise<void> {
  console.log('[ColdStorageSync] Manually triggering cold storage sync...');
  await resetColdStorageSyncCircuitBreaker();
  return coldStorageSync.performSync();
}

==========================================
FILE: src/services/contentService.ts
==========================================

/**
 * @file contentService.ts
 * 
 * Service for handling content-related operations,
 * including sending extracted content to the backend.
 */

import { API_BASE_URL, CONTENT_ENDPOINTS } from '../config';
import { authService } from './authService';
import { ContentData } from '../types';

class ContentService {
  /**
   * Sends extracted content directly to the backend API
   * @param content The extracted content data to send
   * @returns A promise that resolves when the content is sent successfully
   */
  async sendContent(content: ContentData): Promise<boolean> {
    try {
      // Get auth state to include access token
      const authState = await authService.getAuthState();
      
      if (!authState.isAuthenticated) {
        console.log('[ContentService] User not authenticated, skipping content sync');
        return false;
      }

      const endpoint = `${API_BASE_URL}${CONTENT_ENDPOINTS.CONTENT}`;
      
      // Format the request payload
      const payload = {
        pageId: content.pageId,
        visitId: content.visitId,
        sessionId: content.sessionId,
        userId: authState.user?.id,
        timestamp: Date.now(),
        content: {
          url: content.url,
          title: content.title,
          markdown: content.markdown,
          metadata: content.metadata,
        }
      };

      console.log(`[ContentService] Sending content to backend: ${endpoint}`);
      
      // Send the content to the backend
      const response = await fetch(endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${authState.accessToken}`
        },
        body: JSON.stringify(payload)
      });

      if (!response.ok) {
        throw new Error(`Backend returned ${response.status}: ${await response.text()}`);
      }

      console.log('[ContentService] Content sent successfully');
      return true;
    } catch (error) {
      console.error('[ContentService] Error sending content to backend:', error);
      return false;
    }
  }
}

// Create and export a singleton instance
export const contentService = new ContentService();

// Default export for convenience
export default ContentService;


==========================================
FILE: src/services/eventService.ts
==========================================

/**
 * @file eventService.ts
 * 
 * Service for tracking and reporting user events.
 * Uses the repository pattern for database access and clean architecture principles.
 */

import { authService } from './authService';
import { eventRepository, sessionRepository, EventType } from '../db/repositories';

/**
 * Track a search result click event
 * 
 * @param searchSessionId Unique ID for the search session
 * @param pageId ID of the clicked page
 * @param position Position of the result in the list (0-based)
 * @param url URL of the clicked result
 * @param query Search query that produced the result
 * @returns Promise resolving when the event is logged
 */
export async function trackSearchClick(
  searchSessionId: string,
  pageId: string,
  position: number,
  url: string,
  query: string
): Promise<number> {
  try {
    // Verify user is authenticated first
    const authState = await authService.getAuthState();
    if (!authState.isAuthenticated) {
      console.error('[EventService] User not authenticated for trackSearchClick');
      throw new Error('Authentication required');
    }
    
    // Check if DatabaseManager is properly initialized
    const { DatabaseManager } = await import('../db/DatabaseCore');
    if (!DatabaseManager.getCurrentUserId()) {
      console.error('[EventService] Database not initialized for trackSearchClick');
      throw new Error('Database not initialized');
    }
    
    // Get the current session ID
    const sessionId = sessionRepository.getCurrentSessionId();
    if (!sessionId) {
      console.error('[EventService] No active session for trackSearchClick');
      throw new Error('No active session');
    }
    
    // Get the session details
    const session = await sessionRepository.getSession(sessionId);
    if (!session) {
      console.error('[EventService] Could not retrieve session details');
      throw new Error('Session details not found');
    }

    // Use authenticated user info
    const userId = authState.user?.id;
    const userEmail = authState.user?.email;

    // Log the event
    const eventId = await eventRepository.logEvent(
      EventType.SEARCH_RESULT_CLICKED, 
      String(sessionId),
      { 
        searchSessionId, 
        pageId, 
        position, 
        url, 
        query,
        timestamp: Date.now() 
      },
      userId,
      userEmail
    );

    console.log('[EventService] Search click logged:', {
      eventId,
      pageId,
      position,
      query: query.substring(0, 15) + (query.length > 15 ? '...' : '')
    });

    return eventId;
  } catch (error) {
    console.error('[EventService] trackSearchClick error:', error);
    // Propagate authentication and initialization errors
    if (error instanceof Error && 
        (error.message === 'Authentication required' || 
         error.message === 'Database not initialized')) {
      throw error;
    }
    // For other errors, rethrow
    throw error;
  }
}

/**
 * Track that a user performed a search
 * 
 * @param query The search query
 * @param resultCount Number of results returned
 * @param searchType Type of search (local, semantic, hybrid)
 * @returns Promise resolving to the event ID
 */
export async function trackSearchPerformed(
  query: string,
  resultCount: number,
  searchType: 'local' | 'semantic' | 'hybrid' = 'local'
): Promise<{ searchSessionId: string }> {
  try {
    // Verify user is authenticated first
    const authState = await authService.getAuthState();
    if (!authState.isAuthenticated) {
      console.error('[EventService] User not authenticated for trackSearchPerformed');
      throw new Error('Authentication required');
    }
    
    // Get the current session ID
    const sessionId = sessionRepository.getCurrentSessionId();
    if (!sessionId) {
      console.warn('[EventService] No active session for trackSearchPerformed, trying to create one');
      try {
        // Try to create a new session
        const newSessionId = await sessionRepository.startNewSession();
        console.log('[EventService] Created new session:', newSessionId);
      } catch (sessionError) {
        console.error('[EventService] Failed to create new session:', sessionError);
        // Return a temporary search session ID without failing
        return { searchSessionId: `fallback_${Date.now()}_${Math.random().toString(36).substring(2, 7)}` };
      }
    }

    // Use the already fetched authState from above
    const userId = authState.user?.id;
    const userEmail = authState.user?.email;

    // Generate a unique search session ID
    const searchSessionId = `search_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;

    // Log the event
    const eventId = await eventRepository.logEvent(
      EventType.SEARCH_PERFORMED,
      String(sessionId),
      {
        searchSessionId,
        query,
        resultCount,
        searchType,
        timestamp: Date.now()
      },
      userId,
      userEmail
    );

    console.log('[EventService] Search performed:', {
      eventId,
      query: query.substring(0, 15) + (query.length > 15 ? '...' : ''),
      resultCount,
      searchType
    });

    return { searchSessionId };
  } catch (error) {
    console.error('[EventService] trackSearchPerformed error:', error);
    // Propagate authentication and initialization errors
    if (error instanceof Error && 
        (error.message === 'Authentication required' || 
         error.message === 'Database not initialized')) {
      throw error;
    }
    // For other errors, provide a fallback to avoid UI breakage
    return { searchSessionId: `error_${Date.now()}_${Math.random().toString(36).substring(2, 7)}` };
  }
}

/**
 * Class to represent the EventService with all event-related functions
 * This allows for easier mocking and dependency injection
 */
class EventService {
  /**
   * Track a search result click
   */
  trackSearchClick = trackSearchClick;
  
  /**
   * Track a search being performed
   */
  trackSearchPerformed = trackSearchPerformed;
}

// Create and export a singleton instance
export const eventService = new EventService();

// Default export for convenience
export default eventService;


==========================================
FILE: src/services/navigationService.ts
==========================================

/**
 * @file navigationService.ts
 * 
 * Service responsible for tracking user navigation and building the knowledge graph.
 * Handles page records, visits, and navigation edges.
 */

import { pageRepository, sessionRepository, edgeRepository, visitRepository } from '../db/repositories';

// Constants
const SESSION_IDLE_THRESHOLD = 15 * 60 * 1000; // 15 minutes in milliseconds
let isStartingSession = false; // Flag to prevent concurrent session creation

/**
 * Create or get a page record for a URL
 */
export async function createOrGetPage(
  url: string, 
  title: string, 
  timestamp: number
): Promise<string> {
  try {
    // First check if page exists
    const existingPage = await pageRepository.getByUrl(url);
    
    if (existingPage) {
      // Update last visit time and title if changed
      if (existingPage.title !== title || existingPage.lastVisit < timestamp) {
        // Use createOrUpdate which will update the existing page
        await pageRepository.createOrUpdate(url, title, timestamp);
      }
      
      return existingPage.pageId;
    }
    
    // Create new page if it doesn't exist
    const pageId = await pageRepository.createOrUpdate(url, title, timestamp);
    
    console.log(`[NavigationService] Created new page: ${pageId} - ${url}`);
    return pageId;
  } catch (error) {
    console.error(`[NavigationService] Error creating/getting page for ${url}:`, error);
    throw error;
  }
}

/**
 * Start a new visit to a page
 */
export async function startVisit(
  pageId: string,
  sessionId: string,
  fromPageId?: string,
  isBackNavigation?: boolean
): Promise<string> {
  try {
    // Create visit record using startVisit method in repository
    const visitId = await visitRepository.startVisit(
      pageId,
      Number(sessionId), // Convert to number since repository expects sessionId as number
      fromPageId,
      isBackNavigation || false
    );
    
    // Update page visit count - this is now handled by createOrUpdate
    
    console.log(`[NavigationService] Started visit ${visitId} to page ${pageId}`);
    return visitId;
  } catch (error) {
    console.error(`[NavigationService] Error starting visit to page ${pageId}:`, error);
    throw error;
  }
}

/**
 * End a visit to a page
 */
export async function endVisit(visitId: string, timestamp: number): Promise<void> {
  try {
    // Get the visit to update
    const visit = await visitRepository.getVisit(visitId);
    if (!visit) {
      console.warn(`[NavigationService] Cannot end visit ${visitId}: not found`);
      return;
    }
    
    // Calculate time spent
    const timeSpent = timestamp - visit.startTime;
    
    // End the visit
    await visitRepository.endVisit(visitId, timestamp);
    
    // Update page total time
    await pageRepository.updateActiveTime(visit.pageId, timeSpent / 1000); // Convert ms to seconds
    
    console.log(`[NavigationService] Ended visit ${visitId} after ${timeSpent}ms`);
  } catch (error) {
    console.error(`[NavigationService] Error ending visit ${visitId}:`, error);
    throw error;
  }
}

/**
 * Get a visit by ID
 */
export async function getVisit(visitId: string): Promise<any | null> {
  try {
    return await visitRepository.getVisit(visitId);
  } catch (error) {
    console.error(`[NavigationService] Error getting visit ${visitId}:`, error);
    return null;
  }
}

/**
 * Create or update an edge between pages
 */
export async function createOrUpdateEdge(
  fromPageId: string,
  toPageId: string,
  sessionId: string,
  timestamp: number,
  isBackNavigation: boolean
): Promise<string> {
  try {
    // The EdgeRepository's createOrUpdate method handles both creation and updating
    // It checks if the edge exists and updates it, or creates a new one if needed
    const edgeId = await edgeRepository.createOrUpdate(
      fromPageId,
      toPageId,
      Number(sessionId), // Convert to number since repository expects sessionId as number
      timestamp,
      isBackNavigation
    );
    
    // Convert the number edge ID to string to maintain consistent return type
    const stringEdgeId = String(edgeId);
    
    console.log(`[NavigationService] Created edge ${stringEdgeId}: ${fromPageId} → ${toPageId}`);
    return stringEdgeId;
  } catch (error) {
    console.error(`[NavigationService] Error creating/updating edge ${fromPageId} → ${toPageId}:`, error);
    throw error;
  }
}

/**
 * Ensure there is an active session, creating one if needed
 */
export async function ensureActiveSession(): Promise<boolean> {
  // Check if we have a current session
  const currentSessionId = await getCurrentSessionId();
  if (currentSessionId) {
    return true;
  }
  
  // Prevent concurrent session creation
  if (isStartingSession) return false;
  
  isStartingSession = true;
  try {
    // startNewSession will automatically reuse a recent session if available,
    // or create a new one if needed
    const sessionId = await sessionRepository.startNewSession(SESSION_IDLE_THRESHOLD);
    console.log(`[NavigationService] Active session: ${sessionId}`);
    
    // Log session start event
    console.log(`[NavigationService] New session started: ${sessionId}`);
    
    return true;
  } catch (error) {
    console.error(`[NavigationService] Error ensuring active session:`, error);
    return false;
  } finally {
    isStartingSession = false;
  }
}

/**
 * Get the current session ID
 */
export async function getCurrentSessionId(): Promise<string | null> {
  try {
    const sessionId = sessionRepository.getCurrentSessionId();
    // Convert number to string since the function expects to return a string
    return sessionId ? String(sessionId) : null;
  } catch (error) {
    console.error(`[NavigationService] Error getting current session ID:`, error);
    return null;
  }
}

/**
 * Update session activity time
 */
export async function updateSessionActivityTime(duration: number = 0): Promise<void> {
  try {
    const sessionId = await getCurrentSessionId();
    if (!sessionId) return;
    
    await sessionRepository.updateSessionActivityTime(Number(sessionId));
  } catch (error) {
    console.error(`[NavigationService] Error updating session activity time:`, error);
  }
}

/**
 * End current session
 */
export async function endCurrentSession(): Promise<void> {
  try {
    const sessionId = await getCurrentSessionId();
    if (!sessionId) return;
    
    await sessionRepository.endSession(Number(sessionId));
    console.log(`[NavigationService] Ended session: ${sessionId}`);
    
    // Log session end event
    console.log(`[NavigationService] Session ended: ${sessionId}`);
  } catch (error) {
    console.error(`[NavigationService] Error ending current session:`, error);
  }
}

// Create a class for service-oriented usage
export class NavigationService {
  createOrGetPage = createOrGetPage;
  startVisit = startVisit;
  endVisit = endVisit;
  getVisit = getVisit;
  createOrUpdateEdge = createOrUpdateEdge;
  ensureActiveSession = ensureActiveSession;
  getCurrentSessionId = getCurrentSessionId;
  updateSessionActivityTime = updateSessionActivityTime;
  endCurrentSession = endCurrentSession;
}

// Create and export singleton instance
export const navigationService = new NavigationService();

// Default export for convenience
export default navigationService;


==========================================
FILE: src/services/preferencesService.ts
==========================================

/**
 * @file preferencesService.ts
 * 
 * Service for managing user preferences
 * Uses PreferencesRepository for data access
 */

import preferencesRepository, { UserPreferences } from '../db/repositories/PreferencesRepository';

/**
 * Service for managing user preferences
 */
class PreferencesService {
  /**
   * Get all user preferences
   * @returns Promise resolving to user preferences
   */
  async getPreferences(): Promise<UserPreferences> {
    return preferencesRepository.getPreferences();
  }

  /**
   * Get the current theme preference
   * @returns Promise resolving to the theme
   */
  async getTheme(): Promise<UserPreferences['theme']> {
    return preferencesRepository.getTheme();
  }

  /**
   * Toggle between light and dark mode
   * If current theme is 'system', switches to 'dark'
   * @returns Promise resolving to the new theme
   */
  async toggleTheme(): Promise<UserPreferences['theme']> {
    const currentTheme = await this.getTheme();
    let newTheme: UserPreferences['theme'];
    
    // Toggle between light and dark
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark';
        break;
      case 'dark':
      case 'system':
      default:
        newTheme = 'light';
        break;
    }
    
    await preferencesRepository.saveTheme(newTheme);
    return newTheme;
  }

  /**
   * Set the theme preference
   * @param theme The theme to set
   * @returns Promise resolving to the new theme
   */
  async setTheme(theme: UserPreferences['theme']): Promise<UserPreferences['theme']> {
    await preferencesRepository.saveTheme(theme);
    return theme;
  }
}

export default new PreferencesService();


==========================================
FILE: src/services/searchService.ts
==========================================

/**
 * @file searchService.ts
 * 
 * Service for performing search operations across different sources.
 * Combines local browser history search, local database ranking,
 * and semantic search via the backend API.
 */

import { API_BASE_URL, SEARCH_ENDPOINTS, SEARCH_CONFIG } from '../config';
import { SearchResult, SearchResponse } from '../types';
import { authService } from './authService';
import { historySearchService } from '../utils/historySearch';
import { localRanker } from '../utils/localDoryRanking';

/**
 * Options for semantic search
 */
export interface SearchOptions {
  limit?: number;
  useHybridSearch?: boolean;
  useLLMExpansion?: boolean;
  useReranking?: boolean;
}

/**
 * SearchService provides methods for searching across different sources.
 * It orchestrates calls to browser history, local database, and backend API.
 */
class SearchService {
  /**
   * Performs a local search using browser history and local database.
   * 
   * @param query The search query
   * @returns Promise resolving to array of search results
   */
  async searchLocal(query: string): Promise<SearchResult[]> {
    if (!query || query.length < SEARCH_CONFIG.MIN_QUERY_LENGTH) {
      return [];
    }

    try {
      console.log(`[SearchService] Performing local search for: "${query}"`);
      
      // Fetch results from both sources in parallel
      const historyPromise = historySearchService.searchHistory(query);
      const dexiePromise = localRanker.rank(query);
      
      const [historyResults, dexieResults] = await Promise.all([historyPromise, dexiePromise]);
      
      // Merge and sort results
      return this.mergeAndSortResults(historyResults, dexieResults);
    } catch (error) {
      console.error('[SearchService] Error in local search:', error);
      return [];
    }
  }

  /**
   * Performs a semantic search via the backend API.
   * 
   * @param query The search query
   * @param options Search options
   * @returns Promise resolving to array of search results
   */
  async searchSemantic(
    query: string, 
    options: SearchOptions = {}
  ): Promise<SearchResult[]> {
    if (!query || query.length < SEARCH_CONFIG.MIN_QUERY_LENGTH) {
      return [];
    }

    try {
      console.log(`[SearchService] Performing semantic search for: "${query}"`);
      
      const authState = await authService.getAuthState();
      if (!authState.isAuthenticated || !authState.user?.id) {
        console.warn('[SearchService] User not authenticated for semantic search');
        return [];
      }

      const userId = authState.user.id;
      
      const searchParams = new URLSearchParams({
        query,
        userId,
        limit: String(options.limit || SEARCH_CONFIG.MAX_SEMANTIC_RESULTS),
        useHybridSearch: String(options.useHybridSearch !== false),
        useLLMExpansion: String(options.useLLMExpansion !== false),
        useReranking: String(options.useReranking !== false)
      });

      const response = await fetch(`${API_BASE_URL}${SEARCH_ENDPOINTS.SEMANTIC}?${searchParams}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${authState.accessToken}`
        }
      });

      if (!response.ok) {
        throw new Error(`Semantic search failed: ${response.statusText}`);
      }

      const semanticResults = await response.json() as SearchResponse;
      
      // Transform results to ensure they match our SearchResult interface
      return semanticResults.map(result => ({
        id: result.id || `semantic-${result.pageId || result.url}`, // Ensure ID is never undefined
        pageId: result.pageId,
        title: result.title,
        url: result.url,
        score: result.score,
        source: 'semantic',
        explanation: result.explanation,
        snippet: result.snippet
      }));
    } catch (error) {
      console.error('[SearchService] Error in semantic search:', error);
      return [];
    }
  }

  /**
   * Performs both local and semantic search, returning results from both.
   * 
   * @param query The search query
   * @param options Search options for semantic search
   * @returns Promise resolving to object containing both result sets
   */
  async searchHybrid(
    query: string, 
    options: SearchOptions = {}
  ): Promise<{
    localResults: SearchResult[],
    semanticResults: SearchResult[]
  }> {
    if (!query || query.length < SEARCH_CONFIG.MIN_QUERY_LENGTH) {
      return { localResults: [], semanticResults: [] };
    }

    try {
      // Run searches in parallel for better performance
      const [localResults, semanticResults] = await Promise.all([
        this.searchLocal(query),
        this.searchSemantic(query, options)
      ]);

      return { localResults, semanticResults };
    } catch (error) {
      console.error('[SearchService] Error in hybrid search:', error);
      return { localResults: [], semanticResults: [] };
    }
  }

  /**
   * Merges and sorts results from history API and local database.
   * Prioritizes local database results for items found in both sources.
   * 
   * @param historyResults Results from historySearchService
   * @param dexieResults Results from localRanker
   * @returns Merged and sorted array of SearchResult
   */
  private mergeAndSortResults(
    historyResults: SearchResult[],
    dexieResults: Array<{ pageId: string; title: string; url: string; score: number }>
  ): SearchResult[] {
    try {
      // Create a map for quick lookups of history results by URL
      const historyMap = new Map<string, SearchResult>();
      historyResults.forEach(item => {
        historyMap.set(item.url, item);
      });

      // Convert dexieResults to SearchResult format
      const dexieSearchResults: SearchResult[] = dexieResults.map(item => ({
        id: item.pageId,
        pageId: item.pageId,
        title: item.title,
        url: item.url,
        score: item.score,
        source: 'dexie'
      }));

      // Create a set of URLs already covered by dexieResults
      const dexieUrls = new Set(dexieResults.map(item => item.url));

      // Only include history results for URLs not already in dexieResults
      const uniqueHistoryResults = historyResults.filter(item => !dexieUrls.has(item.url));

      // Combine the results
      const combinedResults = [...dexieSearchResults, ...uniqueHistoryResults];

      // Sort by score descending (higher is better)
      combinedResults.sort((a, b) => b.score - a.score);

      // Limit results if needed
      return combinedResults.slice(0, SEARCH_CONFIG.MAX_LOCAL_RESULTS);
    } catch (error) {
      console.error('[SearchService] Error merging search results:', error);
      // In case of error, return whatever we have from history
      return historyResults.slice(0, SEARCH_CONFIG.MAX_LOCAL_RESULTS);
    }
  }
}

// Create and export a singleton instance
export const searchService = new SearchService();

// Default export for convenience
export default SearchService;


==========================================
FILE: src/services/uiCommandService.ts
==========================================

/**
 * @file uiCommandService.ts
 * 
 * Service for handling UI commands between background and content scripts
 * using Comlink for type-safe RPC.
 */

import * as Comlink from 'comlink';
import type { ContentCommandAPI } from '../types';

/**
 * Service for handling UI commands between contexts
 */
export class UICommandService {
  // Store ContentCommandAPI proxies by tab ID
  private tabCommandProxies: Record<number, Comlink.Remote<ContentCommandAPI>> = {};
  
  /**
   * Register a tab's command handler
   * @param tabId The tab ID to register
   * @param port The MessagePort to use for communication
   * @returns Success status
   */
  registerCommandHandler(tabId: number, port: MessagePort): boolean {
    try {
      // Wrap the port with Comlink to create a proxy to the content script's API
      this.tabCommandProxies[tabId] = Comlink.wrap<ContentCommandAPI>(port);
      console.log(`[UICommandService] Registered command handler for tab ${tabId}`);
      return true;
    } catch (error) {
      console.error(`[UICommandService] Failed to register command handler for tab ${tabId}:`, error);
      return false;
    }
  }
  
  /**
   * Unregister a tab's command handler
   * @param tabId The tab ID to unregister
   * @returns Success status
   */
  unregisterCommandHandler(tabId: number): boolean {
    if (this.tabCommandProxies[tabId]) {
      delete this.tabCommandProxies[tabId];
      console.log(`[UICommandService] Unregistered command handler for tab ${tabId}`);
      return true;
    }
    return false;
  }
  
  /**
   * Show or toggle search overlay in a tab
   * @param tabId The tab ID to show the overlay in
   * @param action The action to perform ('show', 'hide', or 'toggle')
   * @returns Promise resolving to success status
   */
  async showSearchOverlay(tabId: number, action: 'show' | 'hide' | 'toggle' = 'toggle'): Promise<boolean> {
    try {
      const proxy = this.tabCommandProxies[tabId];
      if (!proxy) {
        console.warn(`[UICommandService] No command handler for tab ${tabId}`);
        return false;
      }
      
      return await proxy.showSearchOverlay(action);
    } catch (error) {
      console.error(`[UICommandService] Error showing search overlay in tab ${tabId}:`, error);
      return false;
    }
  }
}

// Create and export singleton instance
export const uiCommandService = new UICommandService();
export default uiCommandService;


==========================================
FILE: src/types/auth.ts
==========================================

/**
 * @file auth.ts
 * 
 * Type definitions for the authentication system
 */

import { User } from './user';

/**
 * Authentication state interface
 * Represents the current state of user authentication
 */
export interface AuthState {
  isAuthenticated: boolean;
  user: User | null;
  accessToken: string | null;
  refreshToken: string | null;
  isLoading?: boolean;
  error?: Error | null;
}

/**
 * Response from token exchange with the backend
 */
export interface TokenResponse {
  access_token?: string;
  token?: string;  // Alternative name for access_token
  refresh_token?: string;
  user?: User;
}


==========================================
FILE: src/types/clustering.ts
==========================================

/**
 * @file clustering.ts
 * 
 * Type definitions for clustering functionality
 */

/**
 * Interface for a page within a cluster
 */
export interface ClusterPage {
  page_id: string;
  title: string;
  url: string;
}

/**
 * Interface for a single cluster suggestion from the API
 */
export interface ClusterSuggestion {
  cluster_id: string;
  label: string;
  page_count: number;
  top_pages: ClusterPage[];
}

/**
 * Interface for the cluster response from the API
 */
export interface ClusterResponse {
  suggestions: ClusterSuggestion[];
}


==========================================
FILE: src/types/content.ts
==========================================

/**
 * @file content.ts
 * 
 * Type definitions for content extraction and handling
 */

/**
 * Content extracted from a webpage
 */
export interface ExtractedContent {
  title: string;
  url: string;
  markdown: string;
  timestamp: number;
  metadata?: Record<string, any>;
}

/**
 * Content data with context information ready to be sent to the backend
 */
export interface ContentData {
  pageId: string;
  visitId: string;
  sessionId: string | null;
  url: string;
  title: string;
  markdown: string;
  metadata?: Record<string, any>;
}


==========================================
FILE: src/types/database.ts
==========================================

/**
 * @file database.ts
 * 
 * Type definitions for the Dory database system.
 * Contains interfaces for all database records and tables.
 */

import Dexie from 'dexie';

/**
 * Represents a web page in the database
 */
export interface PageRecord {
  pageId: string;
  url: string;
  title: string;
  domain: string;
  firstVisit: number;
  lastVisit: number;
  visitCount: number;
  totalActiveTime: number;
  personalScore: number;
  syncStatus: 'synced' | 'pending' | 'conflict';
  updatedAt: number;
  hasExtractedContent?: boolean;
  contentAvailability?: 'local' | 'server' | 'both' | 'none';
}

/**
 * Represents a visit to a specific page
 */
export interface VisitRecord {
  visitId: string;
  pageId: string;
  sessionId: number;
  fromPageId?: string;
  startTime: number;
  endTime?: number;
  totalActiveTime: number;
  isBackNavigation?: boolean;
}

/**
 * Represents a navigation from one page to another
 */
export interface EdgeRecord {
  edgeId: number;
  fromPageId: string;
  toPageId: string;
  sessionId: number;
  timestamp: number;
  count: number;
  firstTraversal: number;
  lastTraversal: number;
  isBackNavigation?: boolean;
}

/**
 * Represents a browsing session
 */
export interface BrowsingSession {
  sessionId: number;
  startTime: number;
  endTime?: number;
  lastActivityAt: number;
  totalActiveTime: number;
  isActive: boolean;
}

/**
 * Represents an event in the system
 */
export interface EventRecord {
  eventId: number;
  operation: string;
  sessionId: string;
  userId?: string;
  userEmail?: string;
  timestamp: number;
  data: any;
  loggedAt: number;
}

/**
 * Represents a metadata key-value pair
 */
export interface MetadataRecord {
  key: string;
  value: string;
  updatedAt: number;
}

/**
 * Interface for the Dory database tables
 */
export interface DoryDatabaseTables {
  pages: Dexie.Table<PageRecord, string>;
  visits: Dexie.Table<VisitRecord, string>;
  edges: Dexie.Table<EdgeRecord, number>;
  sessions: Dexie.Table<BrowsingSession, number>;
  events: Dexie.Table<EventRecord, number>;
  metadata: Dexie.Table<MetadataRecord, string>;
}


==========================================
FILE: src/types/index.ts
==========================================

/**
 * @file index.ts
 * 
 * Barrel file for exporting all type definitions
 */

// Export user-related types
export * from './user';

// Export auth-related types
export * from './auth';

// Export database-related types
export * from './database';

// Export content-related types
export * from './content';

// Export search-related types
export * from './search';

// Export clustering-related types
export * from './clustering';

// Export UI command-related types
export * from './ui';


==========================================
FILE: src/types/search.ts
==========================================

/**
 * @file search.ts
 * 
 * Type definitions for search functionality
 */

/**
 * Standard search result interface used across the application
 */
export interface SearchResult {
  id: string;             // Unique ID for the result
  pageId?: string;        // Optional page ID (from Dexie/internal storage)
  title: string;          // Page title
  url: string;            // URL
  score: number;          // Relevance score for ranking
  source?: string;        // Source of the result (e.g., 'history', 'dexie')
  explanation?: string;   // Optional explanation of why this result matched
  snippet?: string;       // Optional text snippet
  timestamp?: number;     // Optional timestamp
  favIconUrl?: string;    // Optional favicon URL
  searchSessionId?: string; // Optional search session ID
  isHighlighted?: boolean;  // Whether result is highlighted
  // History API specific fields
  lastVisitTime?: number; 
  visitCount?: number;   
  typedCount?: number;    
}

/**
 * Search response type
 */
export type SearchResponse = SearchResult[];


==========================================
FILE: src/types/ui.ts
==========================================

/**
 * @file ui.ts
 * Type definitions for UI-related functionality
 */

/**
 * API exposed by content scripts for UI command handling
 */
export interface ContentCommandAPI {
  /**
   * Show, hide, or toggle the search overlay
   * @param action The action to perform
   * @returns Promise resolving to success status
   */
  showSearchOverlay(action: 'show' | 'hide' | 'toggle'): Promise<boolean>;
}


==========================================
FILE: src/types/user.ts
==========================================

/**
 * @file user.ts
 * 
 * User-related type definitions for the Dory frontend
 */

/**
 * Core user interface with essential properties
 */
export interface User {
  id: string;             // Unique identifier for the user
  email: string;          // User's email address
  name?: string;          // Optional display name
  picture?: string;       // Optional profile picture URL
}

/**
 * Extended user information including OAuth-specific data
 */
export interface UserInfo extends User {
  // Additional fields that might come from OAuth providers
  given_name?: string;
  family_name?: string;
  locale?: string;
  verified_email?: boolean;
}


==========================================
FILE: src/utils/comlinkSetup.ts
==========================================

/**
 * @file comlinkSetup.ts
 * 
 * Setup for Comlink RPC communication between different extension contexts
 * (background, content scripts, popup).
 */

import * as Comlink from 'comlink';

// Helper to bridge Chrome's MessagePort to Comlink's Endpoint
function wrapPort(port: chrome.runtime.Port): Comlink.Endpoint {
  return {
    postMessage: port.postMessage.bind(port),
    addEventListener: (type, listener) => {
      if (type === 'message') {
        const handler = (msg: any) => {
          const event = { data: msg } as MessageEvent;
          if (typeof listener === 'function') {
            listener(event);
          } else if (listener && typeof listener === 'object' && 'handleEvent' in listener) {
            listener.handleEvent(event);
          }
        };
        // Save a reference to remove later
        (listener as any)._handler = handler;
        port.onMessage.addListener(handler);
      }
    },
    removeEventListener: (type, listener) => {
      if (type === 'message' && (listener as any)._handler) {
        port.onMessage.removeListener((listener as any)._handler);
      }
    },
    start: () => {}, // No-op for compatibility
  };
}

/**
 * Creates a wrapper for chrome.runtime.onConnect to expose your API via Comlink.
 * Call this in your background script to expose your API.
 * 
 * @param api The API object to expose to other contexts
 */
export function exposeBackgroundAPI<T extends object>(api: T): void {
  // Listen for connection attempts from content scripts
  chrome.runtime.onConnect.addListener((port) => {
    // For each connection, create a Comlink endpoint
    Comlink.expose(api, wrapPort(port));
  });
}

/**
 * Gets a proxied connection to the background API.
 * Call this in content scripts to access the background API.
 * 
 * @returns A proxy object that represents the API exposed by the background
 */
export function getBackgroundAPI<T>(): Comlink.Remote<T> {
  // Connect to the background script
  const port = chrome.runtime.connect({ name: 'comlink-port' });
  
  // Create a Comlink proxy to the background API
  return Comlink.wrap<T>(wrapPort(port));
}


==========================================
FILE: src/utils/faviconUtils.tsx
==========================================

import React, { useState, useMemo, useCallback } from 'react';

interface FaviconProps {
  url: string;
  size?: number;
}

/**
 * Attempts to handle multi-level TLDs (e.g. co.uk).
 * For a domain like: "www.sub.example.co.uk"
 * - The root domain would be "example.co.uk"
 * - The full domain would be "sub.example.co.uk"
 * 
 * NOTE: This is a heuristic and may not be exhaustive for every possible TLD.
 */
function extractRootDomain(domain: string): string {
  // Remove leading 'www.'
  const cleanDomain = domain.replace(/^www\./, '');
  const domainParts = cleanDomain.split('.');
  
  // Heuristic for multi-level TLDs: 
  // If the TLD is short (com, net, org, etc.), we keep the last 2 parts.
  // If it's recognized as a multi-level TLD (co.uk, co.in, etc.), we keep the last 3 parts. 
  // Adjust or refine this logic based on your project's needs.
  const multiLevelTlds = ['co.uk', 'co.in', 'co.jp', 'ac.uk', 'gov.uk'];
  const lastTwo = domainParts.slice(-2).join('.');
  const lastThree = domainParts.slice(-3).join('.');
  
  if (multiLevelTlds.includes(lastThree)) {
    return lastThree;
  }
  return lastTwo;
}

/**
 * Extracts both the full domain and root domain from a URL string
 * This gives us multiple options for favicon retrieval.
 */
export function extractDomains(url: string): { fullDomain: string; rootDomain: string } {
  try {
    // Handle URLs without protocol by prepending https://
    const urlWithProtocol = url.startsWith('http') ? url : `https://${url}`;
    const { hostname } = new URL(urlWithProtocol);
    
    // Remove any leading 'www.' for consistency
    const normalized = hostname.replace(/^www\./, '');
    
    // Extract the root domain (domain.com or domain.co.uk from sub.domain.co.uk)
    const rootDomain = extractRootDomain(normalized);

    return { fullDomain: normalized, rootDomain };
  } catch (error) {
    console.error('Error extracting domains:', error);
    return { fullDomain: '', rootDomain: '' };
  }
}

const Favicon: React.FC<FaviconProps> = ({ url, size = 16 }) => {
  const [serviceIndex, setServiceIndex] = useState(0);
  const { fullDomain, rootDomain } = extractDomains(url);

  // If we fail to parse the domain, don’t bother rendering
  if (!fullDomain) {
    return null;
  }

  // Memoize the list of services so we don’t recalculate it on every render
  const services = useMemo(() => {
    return [
      // Google with full domain
      `https://www.google.com/s2/favicons?domain=${fullDomain}&sz=${size}`,
      // Google with root domain
      `https://www.google.com/s2/favicons?domain=${rootDomain}&sz=${size}`,
      // DuckDuckGo
      `https://external-content.duckduckgo.com/ip3/${fullDomain}.ico`,
      // Direct favicon from full domain
      `https://${fullDomain}/favicon.ico`,
      // Direct favicon from root domain
      `https://${rootDomain}/favicon.ico`
    ];
  }, [fullDomain, rootDomain, size]);

  // We try the current service (based on serviceIndex). If that fails, we try the next one.
  const currentSrc = services[serviceIndex] || services[0];

  // Optional: If you prefer an actual fallback image if all fail, specify it here.
  const fallbackIcon = '/images/fallback-favicon.png';

  const handleImageError = useCallback<React.ReactEventHandler<HTMLImageElement>>(
    (e) => {
      // If we have more services to try, increment the index
      if (serviceIndex < services.length - 1) {
        setServiceIndex(serviceIndex + 1);
      } else {
        // If all services are exhausted, either reduce opacity or switch to fallback icon
        // e.currentTarget.style.opacity = '0.4';
        
        // Example: use a fallback icon so the user sees *some* icon
        e.currentTarget.src = fallbackIcon;
        e.currentTarget.onerror = null; // prevent infinite loop if fallback fails
      }
    },
    [serviceIndex, services, fallbackIcon]
  );

  return (
    <img
      src={currentSrc}
      alt={`Favicon for ${fullDomain}`}
      className="favicon"
      width={size}
      height={size}
      style={{
        marginRight: '8px',
        verticalAlign: 'middle',
        flexShrink: 0
      }}
      onError={handleImageError}
    />
  );
};

export default Favicon;

==========================================
FILE: src/utils/historySearch.ts
==========================================

/**
 * @file historySearch.ts
 * 
 * Service for querying the Chrome browser history API
 * and transforming results into the application's format.
 */

import { SearchResult } from '../types';
import { shouldRecordHistoryEntry } from './urlUtils';
import { SEARCH_CONFIG } from '../config';

/**
 * Service for searching browser history and transforming results
 * into the application's standard format.
 */
class HistorySearchService {
  /**
   * Queries the browser's history using chrome.history.search
   * and maps the results to the SearchResult interface.
   *
   * @param query The search string entered by the user.
   * @returns A promise resolving to an array of SearchResult.
   */
  async searchHistory(query: string): Promise<SearchResult[]> {
    if (!query || query.trim().length === 0) {
      return [];
    }

    console.log(`[HistorySearch] Querying chrome.history for: "${query}"`);

    try {
      const historyItems = await chrome.history.search({
        text: query,
        maxResults: SEARCH_CONFIG.MAX_HISTORY_RESULTS,
        startTime: 0, // Search entire history
      });

      console.log(`[HistorySearch] Found ${historyItems.length} items from chrome.history`);

      // Apply comprehensive filtering using the utility function
      const filteredItems = historyItems.filter(item =>
        shouldRecordHistoryEntry(item.url, item.title, 'searchHistoryAPI')
      );

      console.log(`[HistorySearch] Filtered down to ${filteredItems.length} items`);

      // Transform to application's SearchResult format
      return filteredItems.map(item => ({
        id: item.url!, // Use URL as ID for history items
        url: item.url!,
        title: item.title!,
        source: 'history',
        score: 1, // Default score for history items
        // History-specific fields
        lastVisitTime: item.lastVisitTime,
        visitCount: item.visitCount,
        typedCount: item.typedCount,
      }));
    } catch (error) {
      console.error('[HistorySearch] Error querying chrome.history:', error);
      return []; // Return empty array on error
    }
  }

  /**
   * Legacy method to maintain backward compatibility with existing code.
   * @deprecated Use searchHistory instead
   */
  async searchHistoryAPI(query: string): Promise<SearchResult[]> {
    return this.searchHistory(query);
  }
}

// Create and export a singleton instance
export const historySearchService = new HistorySearchService();

// Default export for convenience
export default HistorySearchService;

// Legacy export to maintain backward compatibility
export const searchHistoryAPI = historySearchService.searchHistory.bind(historySearchService); 

==========================================
FILE: src/utils/idGenerator.ts
==========================================

/**
 * @file idGenerator.ts
 * 
 * Centralized utility for generating IDs across different database entities.
 * Each entity has its own specific ID format and generation requirements.
 */

import normalizeUrl from 'normalize-url';

// -------------------- Page ID Generator --------------------

/**
 * Generates a deterministic page ID from a URL.
 * Will always return the same ID for the same URL, even after normalization.
 * 
 * @param url The URL to generate a page ID for
 * @returns A consistent page ID for the given URL
 */
export function generatePageId(url: string): string {
  try {
    // Normalize the URL to create a consistent string
    const normalizedUrl = normalizeUrl(url, {
      defaultProtocol: 'https',
      normalizeProtocol: true,
      forceHttps: true,
      stripWWW: true,
      removeQueryParameters: [/^utm_\w+/i, 'ref', 'fbclid', 'gclid'],
      removeTrailingSlash: true,
      sortQueryParameters: true
    });
    
    // Simple string hash function (djb2)
    let hash = 5381;
    for (let i = 0; i < normalizedUrl.length; i++) {
      hash = ((hash << 5) + hash) + normalizedUrl.charCodeAt(i);
    }
    
    // Convert to hex and take first 16 chars
    const hashHex = (hash >>> 0).toString(16).padStart(8, '0');
    return `page_${hashHex}`;
  } catch (error) {
    console.error('[IdGenerator] Error generating page ID for URL:', url, error);
    
    // Create a safe fallback that's still deterministic
    const safeUrl = encodeURIComponent(url);
    return `page_fallback_${safeUrl.substring(0, 20)}`;
  }
}

// -------------------- Session ID Generator --------------------

/**
 * Generates a numeric UUID for session IDs.
 * Creates a random 47-bit positive integer (fits within JavaScript's safe integer range).
 * 
 * @returns A numeric ID for a browsing session
 */
export function generateSessionId(): number {
  // Get 6 random bytes (48 bits of randomness)
  const randomBytes = new Uint8Array(6);
  crypto.getRandomValues(randomBytes);
  
  // Convert to a numeric value
  let value = 0;
  for (let i = 0; i < randomBytes.length; i++) {
    value = (value << 8) | randomBytes[i];
  }
  
  // Mask to 47 bits to ensure it's a positive safe integer
  return value & 0x7FFFFFFFFFFF;
}

// -------------------- Edge ID Generator --------------------

/**
 * Generates a numeric UUID for edge IDs.
 * Creates a random 47-bit positive integer (fits within JavaScript's safe integer range).
 * 
 * @returns A numeric ID for a navigation edge
 */
export function generateEdgeId(): number {
  // Uses the same approach as session IDs
  return generateSessionId();
}

// -------------------- Visit ID Generator --------------------

/**
 * Generates a string UUID for visit IDs.
 * Format: v{timestamp}_{random}
 * 
 * @returns A string ID for a page visit record
 */
export function generateVisitId(): string {
  const timestamp = Date.now();
  const random = Math.floor(Math.random() * 1000000).toString().padStart(6, '0');
  return `v${timestamp}_${random}`;
}

// -------------------- Event ID Generator --------------------

/**
 * Generates a numeric UUID for event IDs.
 * Creates a random 47-bit positive integer (fits within JavaScript's safe integer range).
 * 
 * @returns A numeric ID for an event record
 */
export function generateEventId(): number {
  // Uses the same approach as session IDs
  return generateSessionId();
}

// -------------------- Generic ID Generator --------------------

/**
 * Enum of ID types for use with the generic generator
 */
export enum IdType {
  PAGE = 'page',
  SESSION = 'session',
  EDGE = 'edge',
  VISIT = 'visit',
  EVENT = 'event'
}

/**
 * Generic ID generator that can create IDs for any entity type.
 * 
 * @param type The type of entity to generate an ID for
 * @param params Additional parameters needed for certain ID types (e.g., URL for pages)
 * @returns An ID of the appropriate type for the specified entity
 */
export function generateId(type: IdType, params?: any): string | number {
  switch (type) {
    case IdType.PAGE:
      if (!params?.url) {
        throw new Error('[IdGenerator] URL is required for generating page IDs');
      }
      return generatePageId(params.url);
      
    case IdType.SESSION:
      return generateSessionId();
      
    case IdType.EDGE:
      return generateEdgeId();
      
    case IdType.VISIT:
      return generateVisitId();
      
    case IdType.EVENT:
      return generateEventId();
      
    default:
      throw new Error(`[IdGenerator] Unknown ID type: ${type}`);
  }
}

// Export default object with all generators
export default {
  generatePageId,
  generateSessionId,
  generateEdgeId,
  generateVisitId,
  generateEventId,
  generateId,
  IdType
};


==========================================
FILE: src/utils/localDoryRanking.ts
==========================================

/**
 * localDoryRanking.ts
 *
 * Demonstrates an advanced local ranking system with a two-tier approach:
 *  1) Strong text matching (BM25 + specialized tokenization + substring/prefix boosts)
 *  2) Contextual intelligence (recency, Markov transitions, time-of-day, etc.) as tie-breakers.
 */

import { DEBUG, RANKING_CONFIG } from '../config';
import jw from 'jaro-winkler';    // Optional for fuzzy fallback
import * as mathjs from 'mathjs'; // For numeric/entropy ops as needed
import { PageRecord, VisitRecord, EdgeRecord, BrowsingSession } from '../types';
import { 
  pageRepository, 
  visitRepository, 
  edgeRepository, 
  sessionRepository,
  metadataRepository 
} from '../db/repositories';

// -------------------------------------------------------------------------
// 1) Helper Functions
// -------------------------------------------------------------------------

function log(...args: any[]) {
  if (DEBUG) console.log(...args);
}

// -------------------------------------------------------------------------
// 2) Tokenization & Utilities
// -------------------------------------------------------------------------
function tokenizeTitle(text: string): string[] {
  return text
    .toLowerCase()
    .split(/[^a-z0-9]+/)
    .filter(Boolean);
}

function tokenizeUrl(url: string): string[] {
  // Specialized URL tokenization (splits on / ? # : . - _ =)
  return url
    .toLowerCase()
    .split(/[\/\?\#\:\.\-\_\=]+/)
    .filter(Boolean);
}

function computeFrequency(tokens: string[]): Record<string, number> {
  const freq: Record<string, number> = {};
  for (const tk of tokens) {
    freq[tk] = (freq[tk] || 0) + 1;
  }
  return freq;
}

function clamp(value: number, min = 0, max = 1): number {
  return Math.max(min, Math.min(max, value));
}

function toSeconds(ts: number): number {
  return ts > 10000000000 ? Math.floor(ts / 1000) : ts;
}

/**
 * Substring/prefix bonus for quick launch:
 * +2 if query is a prefix of URL
 * +1 if query is a prefix of title
 * +1 if query is found anywhere in URL
 * +0.5 if query is found anywhere in title
 */
function computeSubstringBonus(query: string, page: PageRecord): number {
  if (!query) return 0;
  const q = query.toLowerCase();
  const url = page.url.toLowerCase();
  const title = page.title.toLowerCase();

  let bonus = 0;
  if (url.startsWith(q)) {
    bonus += RANKING_CONFIG.SUBSTRING_BONUS.URL_PREFIX;
  } else if (url.includes(q)) {
    bonus += RANKING_CONFIG.SUBSTRING_BONUS.URL_CONTAINS;
  }
  if (title.startsWith(q)) {
    bonus += RANKING_CONFIG.SUBSTRING_BONUS.TITLE_PREFIX;
  } else if (title.includes(q)) {
    bonus += RANKING_CONFIG.SUBSTRING_BONUS.TITLE_CONTAINS;
  }
  return bonus;
}

// -------------------------------------------------------------------------
// 3) BM25 Implementation (Title + URL) with Weighted URL
// -------------------------------------------------------------------------
interface InvertedIndexDoc {
  pageId: string;
  titleTokens: Record<string, number>;
  urlTokens: Record<string, number>;
  titleLen: number;
  urlLen: number;
}

class BM25Engine {
  private docs: InvertedIndexDoc[] = [];
  private avgTitleLen = 1;
  private avgUrlLen = 1;

  // BM25 parameters from config
  private k1 = RANKING_CONFIG.BM25.K1;
  private bTitle = RANKING_CONFIG.BM25.B_TITLE;
  private bUrl = RANKING_CONFIG.BM25.B_URL;
  private wTitle = RANKING_CONFIG.BM25.WEIGHT_TITLE;
  private wUrl = RANKING_CONFIG.BM25.WEIGHT_URL;

  constructor(pageRecords: PageRecord[]) {
    this.buildIndex(pageRecords);
  }

  private buildIndex(pageRecords: PageRecord[]) {
    this.docs = pageRecords.map((p) => {
      const tArr = tokenizeTitle(p.title);
      const uArr = tokenizeUrl(p.url);
      return {
        pageId: p.pageId,
        titleTokens: computeFrequency(tArr),
        urlTokens: computeFrequency(uArr),
        titleLen: tArr.length,
        urlLen: uArr.length
      };
    });

    const N = this.docs.length || 1;
    this.avgTitleLen = this.docs.reduce((sum, d) => sum + d.titleLen, 0) / N;
    this.avgUrlLen = this.docs.reduce((sum, d) => sum + d.urlLen, 0) / N;
  }

  public computeScores(query: string): Array<{ pageId: string; score: number }> {
    const qTokens = tokenizeTitle(query);
    if (!qTokens.length) {
      return this.docs.map(d => ({ pageId: d.pageId, score: 0 }));
    }

    const N = this.docs.length;
    const docFreq: Record<string, number> = {};
    for (const qt of qTokens) {
      docFreq[qt] = 0;
      for (const d of this.docs) {
        if (d.titleTokens[qt] || d.urlTokens[qt]) {
          docFreq[qt]++;
        }
      }
    }

    const idf: Record<string, number> = {};
    for (const qt of qTokens) {
      const df = docFreq[qt] || 0;
      idf[qt] = Math.log((N - df + 0.5) / (df + 0.5) + 1);
    }

    const results: Array<{ pageId: string; score: number }> = [];
    for (const doc of this.docs) {
      let score = 0;
      for (const qt of qTokens) {
        const freqT = doc.titleTokens[qt] || 0;
        const freqU = doc.urlTokens[qt] || 0;

        const TFt =
          (this.wTitle * freqT * (this.k1 + 1)) /
          (freqT + this.k1 * (1 - this.bTitle + this.bTitle * (doc.titleLen / this.avgTitleLen)));

        const TFu =
          (this.wUrl * freqU * (this.k1 + 1)) /
          (freqU + this.k1 * (1 - this.bUrl + this.bUrl * (doc.urlLen / this.avgUrlLen)));

        score += (idf[qt] || 0) * (TFt + TFu);
      }
      results.push({ pageId: doc.pageId, score });
    }
    return results;
  }
}

// -------------------------------------------------------------------------
// 4) Contextual Signals: Markov Chain, Time-of-Day, Recency, Session
// -------------------------------------------------------------------------
interface MarkovTable {
  [fromPageId: string]: {
    [toPageId: string]: number;
  };
}

function buildMarkovChain(edges: EdgeRecord[]): MarkovTable {
  const table: MarkovTable = {};
  for (const e of edges) {
    if (!table[e.fromPageId]) table[e.fromPageId] = {};
    table[e.fromPageId][e.toPageId] = (table[e.fromPageId][e.toPageId] || 0) + e.count;
  }
  return table;
}

function computeMarkovTransitionProb(
  table: MarkovTable,
  fromPageId: string,
  toPageId: string
): number {
  if (!table[fromPageId]) return 0;
  const total = Object.values(table[fromPageId]).reduce((acc, c) => acc + c, 0) || 1;
  const freq = table[fromPageId][toPageId] || 0;
  return freq / total;
}

interface TimeOfDayHistogram {
  [pageId: string]: number[]; // 24 bins
}

function buildTimeOfDayHistogram(visits: VisitRecord[]): TimeOfDayHistogram {
  const hist: TimeOfDayHistogram = {};
  for (const v of visits) {
    const hour = new Date(v.startTime).getHours(); // 0..23
    if (!hist[v.pageId]) hist[v.pageId] = new Array(24).fill(0);
    hist[v.pageId][hour]++;
  }
  return hist;
}

function computeTimeOfDayProb(hist: TimeOfDayHistogram, pageId: string, hourNow: number): number {
  const arr = hist[pageId];
  if (!arr) return 0;
  const sum = arr.reduce((acc, x) => acc + x, 0);
  return sum ? arr[hourNow] / sum : 0;
}

function multiScaleRecencyScore(
  page: PageRecord,
  visits: VisitRecord[],
  nowSec: number
): number {
  const pageVisits = visits.filter(v => v.pageId === page.pageId);
  if (!pageVisits.length) return 0;

  let shortTerm = 0;
  let mediumTerm = 0;
  let longTerm = 0;
  const log2 = Math.log(2);

  for (const pv of pageVisits) {
    const delta = nowSec - toSeconds(pv.startTime);
    if (delta < 0) continue;

    const shortDecay = Math.exp(- (log2 * delta) / RANKING_CONFIG.TIME_DECAY.SHORT_TERM);
    const medDecay   = Math.exp(- (log2 * delta) / RANKING_CONFIG.TIME_DECAY.MEDIUM_TERM);
    const longDecay  = Math.exp(- (log2 * delta) / RANKING_CONFIG.TIME_DECAY.LONG_TERM);

    const dwell = pv.totalActiveTime || 0;
    const dwellFactor = 1 + (Math.atan(dwell / 30) / (Math.PI / 2)) * 0.3;

    shortTerm  += shortDecay * dwellFactor;
    mediumTerm += medDecay  * dwellFactor;
    longTerm   += longDecay * dwellFactor;
  }
  return (
    RANKING_CONFIG.RECENCY_WEIGHTS.SHORT_TERM * shortTerm + 
    RANKING_CONFIG.RECENCY_WEIGHTS.MEDIUM_TERM * mediumTerm + 
    RANKING_CONFIG.RECENCY_WEIGHTS.LONG_TERM * longTerm
  );
}

interface SessionFeatures {
  recentDomains: Record<string, number>;
}

function buildSessionFeatures(
  sessionId: number | undefined,
  pages: PageRecord[],
  visits: VisitRecord[]
): SessionFeatures {
  const feats: SessionFeatures = { recentDomains: {} };
  if (sessionId === undefined) return feats;
  
  const sessionVisits = visits.filter(v => v.sessionId === sessionId);
  for (const sv of sessionVisits) {
    const page = pages.find(px => px.pageId === sv.pageId);
    if (page) {
      feats.recentDomains[page.domain] = (feats.recentDomains[page.domain] || 0) + 1;
    }
  }
  return feats;
}

function computeSessionContextWeight(
  page: PageRecord,
  features: SessionFeatures
): number {
  return Math.log1p(features.recentDomains[page.domain] || 0);
}

// -------------------------------------------------------------------------
// 5) Feature Vector, Model, Two-Tier Scoring
// -------------------------------------------------------------------------
interface FeatureVector {
  textMatch: number;   // Tier-1 text score
  recency: number;
  frequency: number;
  navigation: number;
  timeOfDay: number;
  session: number;
  regularity: number;
  fuzzyScore: number; // Added: Jaro-Winkler score vs title
}

function computeContextualScore(features: FeatureVector, weights: FeatureVector): number {
  return (
    weights.recency     * features.recency     +
    weights.frequency   * features.frequency   +
    weights.navigation  * features.navigation  +
    weights.timeOfDay   * features.timeOfDay   +
    weights.session     * features.session     +
    weights.regularity  * features.regularity
  );
}

class OnlineLinearModel {
  public weights: FeatureVector;
  public bias = 0;
  private learningRate = 0.01;

  constructor(initial?: Partial<FeatureVector>, bias?: number) {
    this.weights = {
      textMatch: this.initRandom() + 0.1,
      recency:   this.initRandom(),
      frequency: this.initRandom(),
      navigation:this.initRandom(),
      timeOfDay: this.initRandom(),
      session:   this.initRandom(),
      regularity:this.initRandom(),
      fuzzyScore:this.initRandom(), // Added fuzzyScore initialization
    };
    if (initial) {
      // Ensure fuzzyScore is also assigned if provided in initial
      const completeInitial = { fuzzyScore: 0, ...initial };
      Object.assign(this.weights, completeInitial);
    }
    if (typeof bias === 'number') {
      this.bias = bias;
    }
  }
  
  private initRandom(): number {
    return (Math.random() - 0.5) * 0.1;
  }

  /**
   * Combined scoring: Learns weights for all features including textMatch and fuzzyScore.
   * Removed the fixed multiplier for textMatch.
   */
  public predict(f: FeatureVector): number {
    const score =
      this.weights.textMatch   * f.textMatch   +
      this.weights.recency     * f.recency     +
      this.weights.frequency   * f.frequency   +
      this.weights.navigation  * f.navigation  +
      this.weights.timeOfDay   * f.timeOfDay   +
      this.weights.session     * f.session     +
      this.weights.regularity  * f.regularity  +
      this.weights.fuzzyScore  * f.fuzzyScore; // Added fuzzyScore term

    return score + this.bias;
  }

  public update(f: FeatureVector, outcome: number) {
    const rawScore = this.predict(f);
    const prob = 1 / (1 + Math.exp(-rawScore));
    const error = outcome - prob;
    this.bias += this.learningRate * error;

    const reg = 0.0001; // L2 regularization
    this.weights.textMatch   += this.learningRate * (error * f.textMatch   - reg * this.weights.textMatch);
    this.weights.recency     += this.learningRate * (error * f.recency     - reg * this.weights.recency);
    this.weights.frequency   += this.learningRate * (error * f.frequency   - reg * this.weights.frequency);
    this.weights.navigation  += this.learningRate * (error * f.navigation  - reg * this.weights.navigation);
    this.weights.timeOfDay   += this.learningRate * (error * f.timeOfDay   - reg * this.weights.timeOfDay);
    this.weights.session     += this.learningRate * (error * f.session     - reg * this.weights.session);
    this.weights.regularity  += this.learningRate * (error * f.regularity  - reg * this.weights.regularity);
    this.weights.fuzzyScore  += this.learningRate * (error * f.fuzzyScore  - reg * this.weights.fuzzyScore); // Added fuzzyScore update

    this.constrainWeights();
  }
  
  private constrainWeights() {
    const maxW = 5.0;
    const minW = -1.0;
    this.weights.textMatch   = clamp(this.weights.textMatch,   minW, maxW);
    this.weights.recency     = clamp(this.weights.recency,     minW, maxW);
    this.weights.frequency   = clamp(this.weights.frequency,   minW, maxW);
    this.weights.navigation  = clamp(this.weights.navigation,  minW, maxW);
    this.weights.timeOfDay   = clamp(this.weights.timeOfDay,   minW, maxW);
    this.weights.session     = clamp(this.weights.session,     minW, maxW);
    this.weights.regularity  = clamp(this.weights.regularity,  minW, maxW);
    this.weights.fuzzyScore  = clamp(this.weights.fuzzyScore,  minW, maxW); // Added fuzzyScore constraint
    this.bias = Math.max(-3.0, Math.min(3.0, this.bias));
  }
}

// -------------------------------------------------------------------------
// 6) The AdvancedLocalRanker Class
// -------------------------------------------------------------------------
export class AdvancedLocalRanker {
  private pages: PageRecord[] = [];
  private visits: VisitRecord[] = [];
  private edges: EdgeRecord[] = [];
  private sessions: BrowsingSession[] = [];

  private bm25: BM25Engine | null = null;
  private markovTable: MarkovTable = {};
  private timeOfDayHist: TimeOfDayHistogram = {};

  private model = new OnlineLinearModel();
  private lastDisplayedFeatures: Record<string, FeatureVector> = {};

  constructor() {
    if (DEBUG) {
      log('[AdvancedLocalRanker] Constructed.');
    }
  }

  public async initialize(): Promise<void> {
    await this.loadDataFromDB();
    await this.loadModelWeights();

    this.bm25 = new BM25Engine(this.pages);
    this.markovTable = buildMarkovChain(this.edges);
    this.timeOfDayHist = buildTimeOfDayHistogram(this.visits);

    if (DEBUG) {
      log(`[AdvancedLocalRanker] Initialized. Pages=${this.pages.length}, Visits=${this.visits.length}, Edges=${this.edges.length}`);
    }
  }

  public async rank(
    query: string,
    currentPageId?: string,
    now = Date.now()
  ): Promise<Array<{ pageId: string; title: string; url: string; score: number }>> {
    if (!this.bm25) return [];
    const nowSec = toSeconds(now);
    const qLower = query.toLowerCase(); // Lowercase query once

    // 1) BM25 text match
    let results = this.bm25.computeScores(query);

    // 2) Substring/prefix bonus
    results = results.map(r => {
      const page = this.pages.find(p => p.pageId === r.pageId);
      if (!page) return r;
      // Substring bonus is kept for now as it rewards exact matches/prefixes specifically
      const subBonus = computeSubstringBonus(query, page);
      return { pageId: r.pageId, score: r.score + subBonus };
    });

    // Filter out results with very low initial text match (might need tuning)
    results = results.filter(r => r.score >= 0.1); // Lowered threshold slightly

    results.sort((a, b) => b.score - a.score);

    // 3) REMOVED Fuzzy fallback logic - integrated into features now

    // 4) Determine session features
    let sessionId: number | undefined;
    let sessionFeatures: SessionFeatures | null = null;
    if (currentPageId) {
      const relevantVisits = this.visits
        .filter(v => v.pageId === currentPageId)
        .sort((a, b) => b.startTime - a.startTime);
      if (relevantVisits.length) {
        sessionId = relevantVisits[0].sessionId;
        sessionFeatures = buildSessionFeatures(sessionId, this.pages, this.visits);
      }
    }

    // 5) Compute final two-tier scores
    const finalScores = results.map(r => {
      const page = this.pages.find(px => px.pageId === r.pageId);
      if (!page) {
        // Return a default object for type safety, score 0 ensures it ranks low
        return { pageId: r.pageId, title: '', url: '', score: -Infinity };
      }
      const textMatchScore = r.score; // From BM25 + Substring Bonus

      // Calculate features
      const recencyVal = multiScaleRecencyScore(page, this.visits, nowSec);
      const freqVal = Math.log1p(page.visitCount) * (0.5 + page.personalScore);
      const navVal = currentPageId ? computeMarkovTransitionProb(this.markovTable, currentPageId, page.pageId) : 0;
      const hourNow = new Date(now).getHours();
      const todVal = computeTimeOfDayProb(this.timeOfDayHist, page.pageId, hourNow);
      const sessVal = sessionFeatures ? computeSessionContextWeight(page, sessionFeatures) : 0;
      const regVal = this.computeRegularity(page.pageId);
      const fuzzyVal = jw(qLower, page.title.toLowerCase()); // Calculate Jaro-Winkler score

      const features: FeatureVector = {
        textMatch: textMatchScore,
        recency: recencyVal,
        frequency: freqVal,
        navigation: navVal,
        timeOfDay: todVal,
        session: sessVal,
        regularity: regVal,
        fuzzyScore: fuzzyVal // Added fuzzyScore to features
      };
      this.lastDisplayedFeatures[page.pageId] = features;

      const score = this.model.predict(features);
      return { pageId: page.pageId, title: page.title, url: page.url, score };
    }).filter(r => r.score > -Infinity); // Filter out any -Infinity scores from missing pages
    finalScores.sort((a, b) => b.score - a.score);

    // 6) Optional relevance filter
    const filtered = this.applyRelevanceFilter(finalScores, query);

    // 7) Deduplicate results by title and URL, keeping highest score
    const deduplicatedResults: Array<{ pageId: string; title: string; url: string; score: number }> = [];
    const seenTitles = new Set<string>();
    const seenUrls = new Set<string>();

    for (const result of filtered) {
      // Skip if we've already included a result with this title OR this URL
      if (!seenTitles.has(result.title) && !seenUrls.has(result.url)) {
        deduplicatedResults.push({
          pageId: result.pageId,
          title: result.title,
          url: result.url,
          score: result.score
        });
        seenTitles.add(result.title);
        seenUrls.add(result.url);
      }
    }

    return deduplicatedResults;
  }

  public recordUserClick(pageId: string, displayedIds: string[]) {
    const rank = displayedIds.indexOf(pageId);
    if (rank < 0) return;
    const page = this.pages.find(p => p.pageId === pageId);
    if (!page) return;

    // Increase personalScore for clicked item
    const oldScore = page.personalScore;
    const boostFactor = rank >= 3 ? 0.15 : 0.1;
    const newScore = oldScore + boostFactor * (1 - oldScore);
    page.personalScore = clamp(newScore);
    this.updatePageInDB(page);

    // Train model from user feedback
    this.updateModelFromClick(pageId, displayedIds);
  }

  public recordImpressions(pageIds: string[]) {
    // Slight negative reinforcement for unclicked items
    for (const pid of pageIds) {
      const page = this.pages.find(p => p.pageId === pid);
      if (!page) continue;
      const oldScore = page.personalScore;
      const newScore = oldScore + 0.05 * (0 - oldScore);
      page.personalScore = clamp(newScore);
      this.updatePageInDB(page);
    }
  }

  public async refreshData(): Promise<void> {
    await this.loadDataFromDB();
    await this.loadModelWeights();
    if (!this.pages.length) return;

    this.bm25 = new BM25Engine(this.pages);
    this.markovTable = buildMarkovChain(this.edges);
    this.timeOfDayHist = buildTimeOfDayHistogram(this.visits);

    if (DEBUG) {
      log(`[AdvancedLocalRanker] Refreshed. Pages=${this.pages.length}, Visits=${this.visits.length}, Edges=${this.edges.length}`);
      log(`Model weights: ${JSON.stringify(this.model.weights, null, 2)}`);
      log(`Model bias: ${this.model.bias.toFixed(4)}`);
    }
  }

  // -----------------------------------------------------------------------
  // Private / Helper Methods
  // -----------------------------------------------------------------------
  private async loadDataFromDB(): Promise<void> {
    try {
      const [pages, visits, edges, sessions] = await Promise.all([
        pageRepository.getAllPages(),
        visitRepository.getAllVisits(),
        edgeRepository.getAllEdges(),
        sessionRepository.getAllSessions()
      ]);
      this.pages = pages;
      this.visits = visits;
      this.edges = edges;
      this.sessions = sessions;
    } catch (err) {
      console.error('[AdvancedLocalRanker] DB load error:', err);
      this.pages = [];
      this.visits = [];
      this.edges = [];
      this.sessions = [];
    }
  }

  private async loadModelWeights() {
    try {
      const record = await metadataRepository.getByKey('rankingModel');
      if (record) {
        const parsed = JSON.parse(record.value);
        this.model.bias = parsed.bias;
        Object.assign(this.model.weights, parsed.weights);
      }
    } catch (err) {
      console.error('[AdvancedLocalRanker] Failed to load model weights:', err);
    }
  }

  private async saveModelWeights() {
    try {
      await metadataRepository.saveValue(
        'rankingModel',
        JSON.stringify({
          bias: this.model.bias,
          weights: this.model.weights
        })
      );
    } catch (err) {
      console.error('[AdvancedLocalRanker] Failed to persist model weights:', err);
    }
  }

  private async updatePageInDB(page: PageRecord) {
    try {
      await pageRepository.updatePersonalScore(page.pageId, page.personalScore);
    } catch (err) {
      console.error('[AdvancedLocalRanker] Failed to update page in DB:', err);
    }
  }

  /**
   * Compute how regularly the user visits this page, factoring interval
   * consistency (CV) and entropy. 
   */
  private computeRegularity(pageId: string): number {
    const pageVisits = this.visits.filter(v => v.pageId === pageId);
    if (pageVisits.length < 2) return 0.5;

    const sorted = [...pageVisits].sort((a, b) => a.startTime - b.startTime);
    const intervals: number[] = [];
    for (let i = 1; i < sorted.length; i++) {
      intervals.push(sorted[i].startTime - sorted[i - 1].startTime);
    }

    const meanInt = mathjs.mean(intervals) as number;
    const stdInt = mathjs.std(intervals, 'uncorrected') as number;
    const cv = meanInt > 0 ? (stdInt / meanInt) : 0;
    const ent = this.shannonEntropy(intervals);
    const entFactor = pageVisits.length > 1 ? (1.0 + ent / Math.log(pageVisits.length)) : 1.0;
    const r = (1 / (1 + cv)) * entFactor;
    return (isFinite(r) && !isNaN(r)) ? r : 0.5;
  }

  private shannonEntropy(vals: number[]): number {
    const sum = vals.reduce((a, b) => a + b, 0);
    if (sum === 0) return 0;
    const p = vals.map(x => x / sum);
    return -p.reduce((acc, x) => (x > 0 ? acc + x * Math.log(x) : acc), 0);
  }

  private applyRelevanceFilter<T extends { score: number }>(
    scores: T[],
    query: string
  ): T[] {
    if (!scores.length) return scores;
    const queryLength = query.split(/\s+/).filter(Boolean).length;
    const maxScore = scores[0].score;
    if (scores.length <= 2 || (queryLength === 1 && maxScore > 0.3)) {
      return scores;
    }
    const queryComplexity = Math.min(1.0, 0.3 + queryLength * 0.2);
    const midpoint = Math.max(0.1, maxScore * (0.25 - 0.05 * queryComplexity));
    const steepness = 8 + (queryComplexity * 4);

    return scores.filter(result => {
      const normalizedScore = result.score / maxScore;
      const adjustedMidpoint = maxScore < 0.3 ? midpoint * 0.5 : midpoint;
      const prob = 1 / (1 + Math.exp(-steepness * (normalizedScore - adjustedMidpoint)));
      return prob >= 0.3;
    });
  }

  /**
   * Model updates: clicked item => positive label, others => negative label.
   */
  private updateModelFromClick(clickedPageId: string, displayedIds: string[]) {
    let updated = false;
    const clickedFeatures = this.lastDisplayedFeatures[clickedPageId];
    if (clickedFeatures) {
      this.model.update(clickedFeatures, 1);
      updated = true;
    }
    for (const pid of displayedIds) {
      if (pid !== clickedPageId) {
        const f = this.lastDisplayedFeatures[pid];
        if (f) {
          this.model.update(f, 0);
          updated = true;
        }
      }
    }
    if (updated) {
      this.saveModelWeights();
    }
  }
}

export const localRanker = new AdvancedLocalRanker();

==========================================
FILE: src/utils/osUtils.ts
==========================================

/**
 * @file osUtils.ts
 * 
 * Utility functions related to operating system detection and platform-specific behavior.
 */

/**
 * Detects the user's operating system based on navigator properties.
 * Used for displaying appropriate keyboard shortcuts and platform-specific UI elements.
 * 
 * @returns The detected OS as a string ('Mac OS', 'Windows', 'Linux', or 'Unknown')
 */
export function detectOS(): string {
  const userAgent = window.navigator.userAgent;
  const platform = window.navigator.platform;
  const macosPlatforms = ['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'];
  const windowsPlatforms = ['Win32', 'Win64', 'Windows', 'WinCE'];
  
  if (macosPlatforms.indexOf(platform) !== -1) {
    return 'Mac OS';
  } else if (windowsPlatforms.indexOf(platform) !== -1) {
    return 'Windows';
  } else if (/Linux/.test(platform)) {
    return 'Linux';
  } 
  
  // Default to detecting based on userAgent if platform check is inconclusive
  if (userAgent.indexOf('Mac') !== -1) {
    return 'Mac OS';
  } else if (userAgent.indexOf('Win') !== -1) {
    return 'Windows';
  }
  
  return 'Unknown';
}


==========================================
FILE: src/utils/urlUtils.ts
==========================================

/**
 * @file urlUtils.ts
 * 
 * URL utilities for filtering and standardizing web URLs
 */

import { URL_FILTER_CONFIG } from '../config';

/**
 * Checks if a URL is a standard web page. 
 * This helps us skip internal pages like chrome://, devtools://, file://, etc.
 */
export function isWebPage(url: string): boolean {
  return url.startsWith('http://') || url.startsWith('https://');
}

// Create Sets from config arrays for more efficient lookups
const IGNORED_URL_SCHEMES = URL_FILTER_CONFIG.IGNORED_URL_SCHEMES;
const GENERIC_TITLES = new Set(URL_FILTER_CONFIG.GENERIC_TITLES); 
const GOOGLE_SEARCH_DOMAINS = new Set(URL_FILTER_CONFIG.GOOGLE_SEARCH_DOMAINS);
const AUTH_PATH_ENDINGS = new Set(URL_FILTER_CONFIG.AUTH_PATH_ENDINGS);
const AUTH_TITLE_KEYWORDS = URL_FILTER_CONFIG.AUTH_TITLE_KEYWORDS;

/**
 * Checks if a given URL and title should be recorded or included in history results,
 * based on predefined filtering rules.
 *
 * @param url The URL of the page/history item.
 * @param title The title of the page/history item.
 * @param componentName Optional name of the calling component for logging.
 * @returns `true` if the entry should be included, `false` if it should be filtered out.
 */
export function shouldRecordHistoryEntry(
  url: string | undefined | null,
  title: string | undefined | null,
  componentName: string = 'HistoryFilter'
): boolean {
  // 1. Basic Existence Checks
  if (!url || !title) {
    // console.debug(`[${componentName}] Filtered due to missing URL or title:`, url, title);
    return false;
  }

  // 2. Filter out non-web pages
  if (!isWebPage(url)) {
    // console.debug(`[${componentName}] Filtered non-web page:`, url);
    return false;
  }

  // 3. Filter by URL Scheme
  const scheme = url.substring(0, url.indexOf(':') + 1).toLowerCase();
  if (IGNORED_URL_SCHEMES.includes(scheme)) {
    // console.debug(`[${componentName}] Filtered ignored scheme:`, url);
    return false;
  }

  // 4. Filter by Title
  const normalizedTitle = title.trim().toLowerCase();
  if (GENERIC_TITLES.has(normalizedTitle)) {
    // console.debug(`[${componentName}] Filtered generic title:`, url, title);
     return false;
  }

  // --- Updated Auth/Error Checks ---

  // 5. Filter Auth/Error Pages (URL Path and Title)
  try {
    const parsedUrl = new URL(url!);
    const pathname = parsedUrl.pathname.toLowerCase();
    const hostname = parsedUrl.hostname.toLowerCase();
    const searchParams = parsedUrl.searchParams;

    // Check URL Path Endings (handle potential trailing slash)
    const effectivePath = pathname.endsWith('/') ? pathname.slice(0, -1) : pathname;
    for (const ending of AUTH_PATH_ENDINGS) {
      if (effectivePath.endsWith(ending)) {
        // console.debug(`[${componentName}] Filtered auth/action path:`, url);
        return false;
      }
    }

    // Check Title Prefixes/Keywords (using the already normalized title)
    // This now checks if the normalized title *includes* any keyword for errors,
    // or *starts with* for auth/action prefixes.
    for (const keyword of AUTH_TITLE_KEYWORDS) {
      if (normalizedTitle.includes(keyword)) { // Changed to includes for broader matching (e.g., error codes)
        // Add specific startsWith check for auth terms if needed to avoid over-filtering
        // Example: if (keyword.includes('login') && !normalizedTitle.startsWith(keyword)) continue;
        // console.debug(`[${componentName}] Filtered auth/error title:`, url, title);
        return false;
      }
    }

    // --- End Updated Auth/Error Checks ---

    // 6. Filter Google SERPs
    if (GOOGLE_SEARCH_DOMAINS.has(hostname) && searchParams.has('q')) {
      // console.debug(`[${componentName}] Filtered Google SERP:`, url);
      return false;
    }
  } catch (e) {
     console.error(`[${componentName}] URL parsing error during filtering:`, url, e);
     return false; // Treat invalid URLs as filterable
  }

  // If all checks pass, include it
  return true;
}

==========================================
FILE: src/utils/useDarkMode.ts
==========================================


import { useState, useEffect } from 'react';
import { STORAGE_KEYS } from '../config';

/**
 * Hook to manage dark mode theme preference.
 * Retrieves from localStorage, falls back to system preference,
 * and persists changes to localStorage.
 * 
 * @param defaultValue Optional default value for dark mode
 * @returns Object with current dark mode state and toggle function
 */
const useDarkMode = (defaultValue: boolean = false) => {
  const [isDarkMode, setIsDarkMode] = useState(defaultValue);

  // Initialize from localStorage or system preference
  useEffect(() => {
    try {
      const stored = localStorage.getItem(STORAGE_KEYS.PREFERRED_THEME_KEY);
      if (stored) {
        setIsDarkMode(stored === 'dark');
      } else {
        // Fall back to system preference when no stored theme exists
        const systemDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
        setIsDarkMode(systemDarkMode);
      }
    } catch (err) {
      console.error('[useDarkMode] Error reading theme preference:', err);
      // Fall back to system preference on error
      const systemDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
      setIsDarkMode(systemDarkMode);
    }
  }, []);

  // Update DOM and persist preference when theme changes
  useEffect(() => {
    try {
      const root = document.documentElement;
      if (isDarkMode) {
        root.classList.add('dark-mode');
        localStorage.setItem(STORAGE_KEYS.PREFERRED_THEME_KEY, 'dark');
      } else {
        root.classList.remove('dark-mode');
        localStorage.setItem(STORAGE_KEYS.PREFERRED_THEME_KEY, 'light');
      }
    } catch (err) {
      console.error('[useDarkMode] Error saving theme preference:', err);
    }
  }, [isDarkMode]);

  /**
   * Toggle between light and dark mode
   */
  const toggle = () => setIsDarkMode(prev => !prev);

  return { isDarkMode, toggle };
};

export default useDarkMode;